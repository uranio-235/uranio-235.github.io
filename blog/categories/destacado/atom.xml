<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: destacado | El SysAdmin del 3er Mundo]]></title>
  <link href="http://uranio-235.github.io/blog/categories/destacado/atom.xml" rel="self"/>
  <link href="http://uranio-235.github.io/"/>
  <updated>2017-03-18T00:35:45-04:00</updated>
  <id>http://uranio-235.github.io/</id>
  <author>
    <name><![CDATA[låzaro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[portknocking en freebsd]]></title>
    <link href="http://uranio-235.github.io/blog/2017/03/01/portknocking-en-freebsd/"/>
    <updated>2017-03-01T23:53:01-05:00</updated>
    <id>http://uranio-235.github.io/blog/2017/03/01/portknocking-en-freebsd</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/alibaba.jpg" width="400" height="500" title="" ></p>

<p>La técnica port-knocking o knockd para otros, es en mi opinión, <strong>pilar de la
seguridad</strong> en cualquier servidor que use SSH. Aunque es bastante versátil y
puede ser usado hasta para reiniciar servicios sin loguearte.</p>

<p>Una de las cosas que empece a extrañar en FreeBSD fue knockd, pero gracias a la
flexbilidad de ipfw, podemos usar este poderoso software. En FreeBSD el fichero
se encuentra en <strong>/usr/local/etc/knockd.conf.sample</strong> y el paquete se llama
<strong>knock</strong>.</p>

<p>OJO!! Muy importante especificarle la interfaz por la cual va a escuchar.</p>

<pre><code class="ini "/usr/local/etc/knockd.conf""> [options]
         logfile = /var/log/knockd.log
         interface = xn0

 [openSSH]
         sequence    = 111,222,333
         seq_timeout = 9
         command     = /sbin/ipfw -q add 00001 allow all from %IP% to me
         tcpflags    = syn

 [closeSSH]
         sequence    = 222,111,333
         seq_timeout = 9
         command     = /sbin/ipfw -q delete 00001
         tcpflags    = syn
</code></pre>

<p>Nada, resumiendo, que el truco está en poner la regla con el número 00001.
Recuerdas que ipfw te permite (casi te obliga a) especificar un número para cada
regla. Pues usaremos ese numerito diminuto para ponerla de primera.</p>

<p>Los tipos ortodoxos criticarán que es una regla <em>al tetón</em>. Pienso que no vale
la pena abrir solo el 22; si voy a pasar tanto trabajo, que se me abra la puerta
completa.</p>

<p>Por cierto, junto con knock, viene un programita para hacer el knocking. Yo
solía hacerlo con netcat pero knock es más cómodo.</p>

<pre><code class="console "knock"">   knock 192.168.3.1 111,222,333
</code></pre>

<p>En mi <strong>.bashrc</strong>, tengo esta función declarada.</p>

<pre><code class="bash ".bashrc""> abrete_cesamo() {
    knock  $1 111 222 333
    ssh root@$1
    knock  $1 222 111 333
 }
</code></pre>

<p>No tengo que decirte que la combinación de puertos está de acorde al ejemplo de
la entrada y que debes cambiarla por la que tu establezcas. Así de esa manera,
hacerle SSH a un servidor es ejecutar <strong>abrete_cesamo ip.del.servidor</strong> Luego al
terminar la sesión ssh, se ejecuta la secuencia de cerrado.</p>

<p>Y hablando de implementaciones raras de knockd!</p>

<p>En alpine linux, iptables está en <strong>/sbin</strong>, no en /usr/sbin. Sin
embargo, el fichero de configuración tiene puesto que está en /usr/sbin/, lo
cual, repito; no es correcto.</p>

<p>Además, tanto en debian como alpine. No importa que pongas en la configuración
porque interfaz escuchará. Siempre lo hará por eth0. Para cambiar esta
situación; debes:</p>

<p>En <strong>alpine</strong> linux, configurar la interfaz en el fichero <strong>/etc/conf.d/knockd</strong></p>

<p>En <strong>debian</strong>, configurar la interfaz (y poner un 1) en <strong>/etc/default/knockd</strong></p>

<p>Recuerda que en linux, el comando de iptables, viene con &ldquo;-A INPUT&rdquo;. Si tienes
un firewall corriendo, obviamente que no pincha; por tanto, ponlo con &ldquo;-I
INPUT&rdquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ipfw simple y conciso]]></title>
    <link href="http://uranio-235.github.io/blog/2017/02/01/ipfw-simple-y-consiso/"/>
    <updated>2017-02-01T23:15:47-05:00</updated>
    <id>http://uranio-235.github.io/blog/2017/02/01/ipfw-simple-y-consiso</id>
    <content type="html"><![CDATA[<p>Las instrucciones para hacer un cortafuegos realmente <strong>SIMPLE</strong> y la vez
funcional (statefull firewall) con ipfw; sensillamente <em>&ldquo;no existen&rdquo;</em>, al menos
No de manera oficial. El cortafuegos ejemplificado en el handbook es bastante
ortodoxo y no muestra la flexibilidad de ipfw.</p>

<p>Para empezar, el módulo debe ser cargado en el kernel, así que inicializaremos
ipfw como si fuera un demonio más del sistema. Esto quiere decir que lo
añadiremos al <strong>/etc/rc.conf</strong></p>

<pre><code class="bash "/etc/rc.conf""> firewall_enable="YES"
 firewall_type="/usr/local/etc/ipfw.rules"
</code></pre>

<p>Te recomiendo reiniciar ahora; para que todo se cargue correctamente.</p>

<p>La <a href="https://www.freebsd.org/doc/handbook/firewalls-ipfw.html">documentación oficial</a> aclara que
los firewall pueden ser (además) del tipo: open, client, simple, closed o
UNKNOWN. Sin embargo, <strong>en mi opinión</strong> estas configuraciones prefabricadas, no
son suficiente para un servidor (por ejemplo proxy).</p>

<p>Para mantener la armonía chea y anticuada de freebsd; colocamos el cortafuegos
en el etc/ que está bajo /usr/local/. Ten en cuenta que casi todas las
aplicaciones que instales, tendrán su /etc ahí.</p>

<p>Reiniciar ipfw no es tan jamón como un usuario de iptables haría. Hacer un flush
de las reglas, significa quedarse trancado y perder la conexión por ssh. Para
reiniciar el cortafuegos, deberás tener un script que haga flush y además,
reiniciar el servicio. Este scriptsito me lo hice para la faena de toquetear el
cortafuegos</p>

<pre><code class="bash "/usr/local/bin/reiniciar_ipfw.sh""> #!/bin/csh
 service ipfw stop
 ipfw -q flush
 service ipfw start
 ipfw show
</code></pre>

<p>La documentación oficial (y otras muchas) indican que cada regla se cree
enumerada y que bebes mantener esta numeración manualmente. Sin embargo, esto no
es estrictamente necesario. Cada regla incrementará el número de manera
implícita.</p>

<p>La mecánica de ipfw es más sencilla que cualquier firewall de linux en mi
opinión.</p>

<p><strong>ipfw add accion argumento</strong></p>

<p>Si ya conoces <strong>ufw</strong>, te darás cuenta de que es una copia bastante mala de
ipfw, sobre todo; teniendo cuenta que ipfw es un firewall en sí, mientras que
ufw, es un stack que genera instrucciones de iptables.</p>

<p>Algo de lo que linux se ha alejado mucho es el teorema de KISS, pero en BSD, que
es unix ortodoxo, mantiene la simpleza como pilar. De esta manera, una acción
allow, en su forma más simple, es casi lenguaje natural.</p>

<p><strong>ipfw add allow all from 10.99 to me</strong></p>

<p>O sea, permite todo lo que venga de 10.0.0.1 para mi. Pero podemos hacer algo
más discriminatorio.</p>

<p><strong>ipfw add allow tcp from 10.0.0.99 to 10.0.0.1 dst-port 22 in via xn0</strong></p>

<p>Permite el tráfico tcp de 10.99 para 10.1 que valla para el puerto 22 en sentido
entrante (in) por la interfaz (via) xn0</p>

<p>¿Te la llevaste? Jamón de pollo! ¿Verdad?</p>

<p>Veamos pues un <strong>ipfw.rules</strong> bien básico. La interfaz <strong>lo0</strong> (lo con un cero)
es el localhost. La interfaz xn0 es la WAN y xn1 es la LAN.</p>

<pre><code class="bash "ipfw.rules""> # permite todo por el localhost
 ipfw -q add allow all from any to any via lo0

 # las conexiones que ya estén iniciadas, pásalas
 # compara eso con el de iptables
 ipfw -q add allow tcp from any to any established

 # permite que te hagan ping desde la LAN 
 # pero no mucho icmp para que no hagan flood
 ipfw pipe 1 config bw 30KBytes
 ipfw -q add pipe 1 icmp from 192.168.1.0/24 to me in via xn1
 ipfw -q add allow  icmp from 192.168.1.0/24 to me in via xn1

 # permite que accedan al proxy desde la LAN
 ipfw -q add allow tcp from 192.168.1.0/24 to me 3128 via xn1

 # permite el servidor web pero solo deade la WAN
 # en este caso "me" será la ip de la WAN
 ipfw -q add allow tcp from any to me dst-port 80 via xn0

 # descarta el resto de los paquetes ENTRANTES
 # esta regla casi nunca es necesaria, ya que
 # suele ser implícita, o sea, drop por defecto
 ipfw -q add drop all from any to any

 # finalmente, PA AFUERA, permitimos todo
 ipfw -q add allow all from any to any out
</code></pre>

<p>Veamos algunas características de este cortafuegos&hellip;</p>

<p>Como ven, no arranca haciendo flush como los de iptables. De hecho, hacer flush
como primera linea puede causarte problemas muy serios. Por otro parte,
reiniciar el cortafuegos sin hacer flush, provoca que se dupliquen las reglas.</p>

<p>La salida, por definición, está bloqueada. La última regla; autoriza la salida
del tráfico. ¿Por qué la última? ¿Por qué no al principio? Pues por si hacemos
un pipe de salida. Aveces regular el ancho de banda de salida, es más útil que
regular el de entrada. Por ejemplo, si queremos moderar la cantidad de tráfico
que un servidor web exporta. Más adelante veremos dummynet y los pipe.</p>

<p>En iptables, hacemos DROP cuando queremos desechar paquetes. En ipfw usamos
<strong>deny</strong>, aunque también puedes usar <strong>drop</strong> que es sinónimo de deny. El
cortafuego lo sustituirá por deny. Lo puedes ver al usar: ipfw show</p>

<p>Note que &ldquo;<strong>from me</strong>&rdquo; para ipfw, significa un paquete que provenga de cualquiera de
las ip que tiene configurada el servidor. En este caso, la interfaz xn0 debe
tener alguna de la red 192.168.1.0/24 así que <strong>me</strong> será dicha ip.</p>

<p>Una característica de ipfw <strong>bien peligrosa</strong> es que tiene muchas cosas
<strong>implícitas</strong>. Como lo de la numeración. Cuando digo implícita me refrito a que
si no las pones, ipfw las asume. Fíjate bien como se maneja el tema de los
puertos en la siguientes reglas.</p>

<pre><code class="bash "ipfw dst-port""> # permite que accedan al proxy desde la LAN
 ipfw -q add allow tcp from 192.168.1.0/24 to me 3128 via xn1

 # permite el servidor web pero solo deade la WAN
 # en este caso "me" será la ip de la WAN
 ipfw -q add allow tcp from any to me dst-port 80 via xn0
</code></pre>

<p>En la primera regla, declaramos &ldquo;<strong>me 3128</strong>&rdquo;, esto significa &ldquo;para mi ip por el
puerto 3128&rdquo;. Realmente ipfw lo reescribe (puedes verlo con &ldquo;show&rdquo;) y pondrá la
cláusula <strong>dst-port</strong> al igual que la siguiente linea, detrás de <strong>me</strong> viene la
cláusula <strong>dst-port</strong> seguida por el puerto. Pero si no la pones, se asume como
implícita. En poca palabras:</p>

<p>&ldquo;to me 3128&rdquo; y &ldquo;to me dst-port 3128&rdquo; es exactamente lo mismo.</p>

<p>Otro tema que le retraquetea el mango; es la gestión del ancho de vianda. Porque
tc de iproute (en linux) es un asco. Pero si conocemos ipfw, sabremos que maneja
el ancho de vianda de una menera muy peculiar; usando un módulo llamado
dummynet. No esperes ver la palabra &ldquo;dummynet&rdquo; escrita en el cortafuegos. En
fin; analiza este ejemplo:</p>

<pre><code class="bash "ipfw y dummynet""> ipfw add pipe 1 ip from me to 192.168.1.0/24 out via xn0
 ipfw pipe 1 config bw 128KBytes
</code></pre>

<p>Se crea el pipe número 1, con un ancho de banda de 128 KyloBytes. En la regla de
arriba, se dijo que todo el tráfico de la interfaz xn0, proveniente de el
servidor hacia la red 192.168.1.0/24 y en sentido saliente; será a 128K. O sea,
modificamos el ancho de banda <strong>que sale</strong> del servidor, lo cual es bastante
útil para un servidor web o ftp.</p>

<p>En el caso de un servidor proxy, no vale la pena modificar el ancho de banda de
<strong>salida</strong>, ya que las páginas son enviadas al cliente una vez bajadas y si ya
nos hicimos el arakiri de bajarla: ¿Pa que demorarlas más? Para un servidor
proxy usamos una regla bidireccional. O sea, creamos el pipe 1 y el pipe 2 con
igual o diferente ancho de banda y aplicamos una regla pa afuera y otra pa
adentro.</p>

<p>Tenga en cuenta que el las conexiones HDSL tiene más ancho de vianda pa abajo
que pa arriba. Osea, que salida a la WAN (el router) debe ser más estrecha que
salida a la LAN.</p>

<p>En un servidor de correo sí sería útil regular la entrada, ya que hay gente que
manda elefantes por el puerto 25. Sobre todo en redes conmutadas o muy lentas.
También sería útil moderar la entrada en un servidor que involucre subida de
ficheros, por ejemplo, una nube, un servidor de carpetas compartidas.</p>

<p>Ah! por cierto:</p>

<p>Si crearas un pipe y le dijeras que 3 ip, lo usan, el ancho de vianda sería
compartido para esas 3 ip. O sea</p>

<pre><code class="bash "ipfw y dummynet""> ipfw add pipe 1 ip from me to 192.168.1.10/24 out via xn0
 ipfw add pipe 1 ip from me to 192.168.1.11/24 out via xn0
 ipfw add pipe 1 ip from me to 192.168.1.12/24 out via xn0
 ipfw pipe 1 config bw 128KBytes
</code></pre>

<p>En este caso, 10, 11 y 12, tienen un total de 128KB/s, si 10 acapara todo el
ancho de banda (los 128) entonces 11 y 12 tendrán unos bellos timeout como
respuesta. Piensa en todo lo que puedes hacer con eso.</p>

<p><strong>OJO CON EL ÓRDEN!!!</strong></p>

<p>Esa regla machea <strong>la salida</strong>. Si la colocaras <strong>debajo</strong> de la regla que
permite todo hacia afuera, simplemente, <strong>no pinchará</strong> porque <strong>no machea</strong>.
Coge por la regla de salida y nunca va al pipe. Como diría los yumas &ldquo;rule of
thumbs&rdquo;</p>

<p><strong>Las reglas que envían el tráfico al pipe, debes ponerlas arriba de la regla
&ldquo;destino final&rdquo; del paquete.</strong></p>

<p>De esta manera el paquete va al pipe y luego regresa al cortafuegos. O sea,
intenta poner siempre los pipe arriba y el cortafuegos abajo</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cambiar mac a un nano]]></title>
    <link href="http://uranio-235.github.io/blog/2016/12/27/cambiar-mac-a-un-nano/"/>
    <updated>2016-12-27T09:39:44-05:00</updated>
    <id>http://uranio-235.github.io/blog/2016/12/27/cambiar-mac-a-un-nano</id>
    <content type="html"><![CDATA[<p>Un socio me preguntó hace poquito si yo podía cambiarle la MAC a un nano. Me
pareció muy estrafalaria la necesidad de él, pero según me contó, en la red
criolla que está suscrito, suelen banear los nanos cuando los usuarios se portan
mal.</p>

<p>Tras una búsqueda en internet vi unos post en un forum pero ninguno me funcionó.
La idea es, correr un fichero al iniciar el sistema, que corra ifconfig y le
cambie la MAC a las interfaces.</p>

<p>La problemática radica, que a la interfaz &ldquo;ath0&rdquo;, no se le puede cambiar la MAC,
ya que aún estando down, te dice dispositivo ocupado. Por esa razón, parecía no
pinchar la solución de los post. Sin embargo, si bajas las 3 interfaces
involucradas en la conexión, luego cambias dichas mac, <strong>sí pincha</strong>.</p>

<p>Para ello crearemos el fichero <strong>/etc/persistent/rc.poststart</strong></p>

<pre><code class="bash "/etc/persistent/rc.poststart"">#!/bin/sh

ifconfig br0 down
ifconfig wifi0 down
ifconfig ath0 down

ifconfig wifi0 hw ether 5e:53:84:bc:a3:54
ifconfig ath0 hw ether 5e:53:84:bc:a3:54

ifconfig ath0 up
ifconfig wifi0 up
ifconfig br0 up
</code></pre>

<p>A ese fichero le ponemos el ejecutable, si no, no pinchará.</p>

<pre><code class="bash "ejecutable"">XW.v5.6.2# chmod a+rx /etc/persistent/rc.poststart 
</code></pre>

<p>Finalmente, le decimos al firmware que modifique los cambios y que reinicie.</p>

<pre><code class="bash "salva y reinicia"">XW.v5.6.2# cfgmtd -w -p /etc/
XW.v5.6.2# reboot
</code></pre>

<p>Todavía hay quien cree que las MAC son una medida segura para crear reglas de
control de acceso&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sysinfo en el motd]]></title>
    <link href="http://uranio-235.github.io/blog/2016/11/20/sysinfo-en-el-motd/"/>
    <updated>2016-11-20T17:13:27-05:00</updated>
    <id>http://uranio-235.github.io/blog/2016/11/20/sysinfo-en-el-motd</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/sysinfo.png" width="400" height="500" title="" ></p>

<p>Desde que lo vi en unbuntu server, había querido hacer que mi servidores
mostraran un overview en el <a href="https://en.wikipedia.org/wiki/Motd_(Unix">MOTD</a>)</p>

<p>Al menos debian, tiene una manera de cambiar el MOTD dinamicamente. Para sazonar
bien el MOTD, vamos a usar figlet, una aplicación que genera letras en ascii-art a
partir de una palabra dada.</p>

<pre><code class="bash "instalando todo"">aptitude install figlet
</code></pre>

<p>El directorio <strong>/etc/update-motd.d/</strong> ejecutará en orden alfabético (o numérico
en nuestro caso) aquellos script cuya salida estandard, compondrán nuestro MOTD.</p>

<pre><code class="bash "aprovisionando el update-motd.d"">mkdir /etc/update-motd.d/
cd /etc/update-motd.d/
touch 00-header &amp;&amp; touch 01-sysinfo &amp;&amp; touch 02-footer
chmod +x /etc/update-motd.d/*
</code></pre>

<p>Finalmente, nos echamos el MOTD de debian por defecto; que no deja de
restregarnos en cara la falta de garantía.</p>

<p>Además, el fichero <strong>/var/run/motd</strong> contendrá nuestro motd resultante, así que
lo lincamos con el que borramos.</p>

<pre><code class="bash "aprovisionando el update-motd.d"">rm /etc/motd
ln -s /var/run/motd /etc/motd
</code></pre>

<p>Por una cuestión de organización, usaremos 3 ficheros:</p>

<p><strong>00-header</strong> con lo que queremos poner primero. En este caso, el nombre y
version de la distribución, además de un mensajito de bienvenida.</p>

<pre><code class="bash "00-header"">#!/bin/bash
[ -r /etc/lsb-release ] &amp;&amp; . /etc/lsb-release
if [ -z "$DISTRIB_DESCRIPTION" ] &amp;&amp; [ -x /usr/bin/lsb_release ]; then
        DISTRIB_DESCRIPTION=$(lsb_release -s -d)
fi
figlet $(hostname)
printf "\n"
printf "Welcome to %s (%s).\n" "$DISTRIB_DESCRIPTION" "$(uname -r)"
printf "\n"
</code></pre>

<p>Yo instalo los sistemas en inglés, así que para mantener todo parejo, escribimos
<em>güelcome</em> y lo hacemos con <strong>printf</strong> para procesar mejor los &ldquo;\n&rdquo; y que pinche
sin importar la shell que se esté usando.</p>

<p>El segundo fichero será <strong>01-sysinfo</strong> y contendrá la parte linda, de la memoria
RAM en uso, el CPU, la carga y la dirección ip de la primera interfaz.</p>

<pre><code class="bash "01-sysinfo"">#!/bin/bash
date=`date`
load=`cat /proc/loadavg | awk '{print $1}'`
root_usage=`df -h / | awk '/\// {print $(NF-1)}'`
memory_usage=`free -m | awk '/Mem:/ { total=$2 } /buffers\/cache/ { used=$3 } END { printf("%3.1f%%", used/total*100)}'`
swap_usage=`free -m | awk '/Swap/ { printf("%3.1f%%", "exit !$2;$3/$2*100") }'`
users=`users | wc -w`
time=`uptime | grep -ohe 'up .*' | sed 's/,/\ hours/g' | awk '{ printf $2" "$3 }'`
processes=`ps aux | wc -l`
ip=`ip a  s dev eth0|grep inet|awk '{print $2}'|cut -d '/' -f 1`

printf "System information as of: $date\n" 
printf "System load:\t%s\tIP Address:\t%s\n" $load $ip
printf "Memory usage:\t%s\tSystem uptime:\t%s\n" $memory_usage "$time"
printf "Usage on /:\t%s\tSwap usage:\t%s\n" $root_usage $swap_usage
printf "Local Users:\t%s\tProcesses:\t%s\n\n" $users $processes
</code></pre>

<p>Por último <strong>02-footer</strong> será la parte de abajo. Contendrá cualquier cosa que
quieras poner en el fichero <strong>/etc/motd.tail</strong> por ejemplo, una anotación que
quieras hacer específica para ese servidor. Se mostrará si existe el fichero.</p>

<pre><code class="bash "02-footer"">#!/bin/bash
[ -f /etc/motd.tail ] &amp;&amp; cat /etc/motd.tail || true
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dkim y spf en postfix]]></title>
    <link href="http://uranio-235.github.io/blog/2016/06/18/dkim-y-spf-en-postfix/"/>
    <updated>2016-06-18T13:57:51-04:00</updated>
    <id>http://uranio-235.github.io/blog/2016/06/18/dkim-y-spf-en-postfix</id>
    <content type="html"><![CDATA[<p>Aunque no de mi agrado, reconozco que es una solución muy buena. DKIM y SPF, se
ha vuelto hoy en día un mecanismo para mitigar el SPAM en el correo electrónico.</p>

<p>Esto no quita, que un spammer puede hacerse con un buen esquema de DKIM para sus
dominos de porquería; lo cual sería un estupendo negocio, teniendo en cuenta que
un servidor puede tener tantos dominios como quiera. Si conoce a algún spammer
que quiera tener DKIM y SPF en su negocio, por favor, mándele mi tarjeta.</p>

<p>Me imagino que a los usuarios de nauta, les duela bajar un mensaje que
aparentemente tiene dos lineas, pagando por uno que realmente tiene más de 20
líneas de pura mierda que no les incumbe. Espero que etecsa se digne a retirar
encabezados innecesarios como esos (para el cliente).</p>

<p>Por otra parte, mucha gente tiene antivirus que modifican el correo o son
fanáticos a instalar mil gangarreas (mailscanner, clamav, etc&hellip;) que también
modifican el correo. Con esto, DKIM y SPF <strong>se van a la mierda</strong>.</p>

<p>Le diré que hice con un postfix que ya estaba instalado en un debian8 para
ponerle DKIM y SPF.</p>

<p>Instalamos los jueguetes requeridos ante todo:</p>

<pre><code class="bash">apt-get install opendkim opendkim-tools postfix-policyd-spf-python
</code></pre>

<p>y establecemos los permisos adecuados, ojo con esto, ya que dkim es muy riguroso
con el tema de los permisos</p>

<pre><code class="bash">adduser postfix opendkim
</code></pre>

<h2>SPF</h2>

<p>Ahora procedemos a crear el registro DNS. Como hay muchos DNS y cada quién tiene
sus preferencias, me reduciré a describir de manera abstracta los registros.
Usted, aterrize la idea en su DNS.</p>

<h3>Esto tiene <strong>DOS</strong> formas de hacerse:</h3>

<h4>La primera:</h4>

<p>Declarar que TODOS los <strong>MX</strong> del dominio, pueden mandar correo (lo cual
inspira desconfianza) en este caso, registra un puntero del tipo <strong>TXT</strong> con el
siguiente valor</p>

<pre><code>v=spf1 mx -all
</code></pre>

<p>Por ejemplo, bind9</p>

<pre><code class="cfg "registro"">@               IN      TXT     "v=spf1 mx -all"
</code></pre>

<h4>La segunda:</h4>

<p>Declarar que un host, que tiene un registro <strong>A</strong>, está autorizado a enviar
correos (esta me gusta más, si tienes un solo servidor de correo) Si fueran
varios, por ejemplo 3. Podrías declarar un A para cada uno y de manera
individual, ellos generarían su SPF apuntándose a si mismo.</p>

<pre><code>v=spf1 a:mx1.tudominio.cu -all
</code></pre>

<p>Como ya sabemos, un puntero MX siempre deberá apuntar a un rgistro A, ya que no
se recomienda apuntar a un CNAME&hellip;</p>

<p><strong>Nota para los apurados:</strong> &ldquo;Si declaras ambos registros, no pincha, LEE!!&rdquo;</p>

<p>Otra cosa, puedes declarar <strong>-all</strong> o <strong>~all</strong> El primero le dirá al receptor
que si el correo no viene del dominio que dice enviarlo (el puntero A o los MX),
lo rechace porque es falso (muy radical) y el segundo, que empieza por ~ le
indica al receptor, que puede recibir el mensaje y si no pude verificarlo que lo
marque como spam, pero que por favor, no lo rechaze.</p>

<p>Esto nos lleva a una:</p>

<h3>Situación peligrosa</h3>

<p>Cuba, un descerebrado configuró verificación de DKIM, <strong>porque está de moda</strong>.
PERO! Está detrás de un smarthost (pasarela) o simplemente, su configuración de
DNS no vale un quilo (por culpa del proveedor)</p>

<p>Metedura de pata - A:</p>

<p>Ese servidor de correo, que se cree <em>Oggun con machete en mano</em>; descartará todo
correo con <strong>-all</strong> debido a su incapacidad de realizar un lookup decente.</p>

<p>Metedura de pata - B:</p>

<p>Uno más descerebrado todavía, vio que DKIM estaba de moda y sin importar que no
tiene control de su DNS, lo hizo todo, saltándose el paso del DNS. Su servidor
le estará gritando a toda voz al mundo entero, <strong>que está falseando el dominio</strong></p>

<p>Su ignorancia le costará caer de cabeza en las listas negras&hellip;</p>

<p>Y es que:</p>

<p>Generalmente, los servidores que entregan a través de un smarthost, carecen de
DNS real. También hay una pila de gente que administran servidores sin tener
control de su DNS.</p>

<h4>Seguimos&hellip;</h4>

<p>Ya que tenemos el SPF pinchando, podemos añadirle chequeo de SPF a nuestro
postfix <strong>que tiene bien configurado el DNS y entrega de cara a internet sin
smarthost</strong></p>

<p>En el fichero <strong>/etc/postfix/master.cf</strong> le agregamos esto:</p>

<pre><code class="cfg master.cf">policyd-spf  unix  -       n       n       -       0       spawn
    user=policyd-spf argv=/usr/bin/policyd-spf
</code></pre>

<p>y a los posftfix cubanos, le decimos que sea paciente con el proceso de
verificación, incrementando el tiempo que tiene que esperar por el policyd, ya
que dicha verificación puede tardar (dns lookup, cpu a tope, etc..) Añadimos
esto a <strong>/etc/postfix/main.cf</strong></p>

<pre><code class="cfg main.cf">policyd-spf_time_limit = 3600
</code></pre>

<p>Ahora viene una parte complicada, pues no hay manera de que pueda reflejarla
como para copiar y pegar.</p>

<p>Deberás modificar tus reglas de postfix, de forma que antepongas el chequeo SPF,
como una más de tus restricciones de recibo. Para mi caso, está bien la última
linea.</p>

<pre><code class="cfg "scpe del main.cf"">
smtpd_sender_restrictions =
   reject_non_fqdn_sender,
   reject_non_fqdn_recipient,
   permit_sasl_authenticated,
   reject_unknown_sender_domain,
   reject_unknown_recipient_domain,
   reject_rbl_client bl.spamcop.net,
   reject_rbl_client sbl.spamhaus.org,
   reject_rbl_client xbl.spamhaus.org,
   defer_unauth_destination,
   reject_unverified_sender,
   check_policy_service unix:private/policyd-spf
</code></pre>

<p>Reinicia postfix y chequea el <strong>/var/log/mail.log</strong> para que veas SPF pinchando.</p>

<h2>DKIM</h2>

<p>Me parece que la configuración de DKIM en debian está buena, pero por si las
moscas. Copias esta que pongo aquí y métela en tu <strong>/etc/opendkim.conf</strong></p>

<pre><code class="cfg /etc/opendkim.conf">Syslog          yes
UMask           002
UserID          opendkim
KeyTable        /etc/opendkim/key.table
SigningTable        refile:/etc/opendkim/signing.table
ExternalIgnoreList  /etc/opendkim/trusted.hosts
InternalHosts       /etc/opendkim/trusted.hosts
Canonicalization    relaxed/simple
Mode            sv
SubDomains      no
#ADSPAction     continue
AutoRestart     yes
AutoRestartRate     10/1M
Background      yes
DNSTimeout      5
SignatureAlgorithm  rsa-sha256
OversignHeaders     From
</code></pre>

<p>De ahí puede que quizás te interese la variables <strong>SubDomains</strong>, sobre todo si
eres proveedor de correo.</p>

<p>Como ya te dije, los permisos son sumamente importantes en este caso</p>

<pre><code class="bash permisos">chmod u=rw,go=r /etc/opendkim.conf
</code></pre>

<p>Ahora creamos el directorio donde vamos a meter todo el zoológico requerido para
que DKIM pinche. Hay quién prefiere meterlo en <strong>/var</strong>, para mi en
<strong>/etc/opendkim</strong> es un buen lugar.</p>

<pre><code class="bash "creando el directorio de residencia"">mkdir /etc/opendkim
mkdir /etc/opendkim/keys
chown -R opendkim:opendkim /etc/opendkim
chmod go-rw /etc/opendkim/keys
</code></pre>

<h3>La Firma</h3>

<p>Ahora vamos a crear la <em>tabla de rúbricas</em> (se aceptan contribuciones para
traducir). Ahí, ponemos una linea por cada dominio que tengas. Creas el fichero
<strong>/etc/opendkim/signing.table</strong> y está recomendado que le pongas lo siguiente:</p>

<pre><code class="cfg "como dicen que debe ser"">   *@tudominio.cu   tudominio
</code></pre>

<p><strong>Nota para los imbéciles:</strong> No olvide remplazar <em>tudominio.cu</em> por el nombre
del dominio suyo.</p>

<p>Con eso, casamos todos los correos que parezcan a tu dominio, con el DKIM que
llamamos &ldquo;tudominio&rdquo;, si quiere atrás le puede poner &ldquo;pepe&rdquo;. Lo que debe
quedarte claro, es que todos los correos que macheen a la expresión regular de
alante, pasarán por el filtro llamado <em>tudominio</em> (o &ldquo;pepe&rdquo; si lo cambiaste) ¿Se
entendió?</p>

<p>Por ejemplo, si tu dominio fuera *@cacocum.hlg.sld.cu podrías ponerle detrás
&ldquo;midkim&rdquo; para que todos los correos de ese dominio, se firmen con la firma que
será configurada bajo el nombre &ldquo;midkim&rdquo; Quedaría así:</p>

<pre><code>  *@cacocum.hlg.sld.cu  midkim
</code></pre>

<p>Resumen:</p>

<p>El primero campo, es una expresión regular que mache las direcciones de correo y
el segundo el nombre de la firma que se usará. Para mayor confusión, se
recomienda que se hagan nombres parecidos. Finalmente nos quedó así:</p>

<pre><code class="cfg /etc/opendkim/signing.table">*@tudominio.cu    tudominio
</code></pre>

<h3>La clave</h3>

<p>Ahora creamos el fichero, donde le diremos a &ldquo;midkim&rdquo; donde va a encontrar su
parafernalia cifradora. Crea el fichero <strong>/etc/opendkim/key.table</strong> y ponle
dentro esto:</p>

<pre><code class="cfg /etc/opendkim/key.table">tudominio     tudominio.cu:YYYYMM:/etc/opendkim/keys/example.private
</code></pre>

<p><strong>IMPORTANTE</strong></p>

<p>Remplaza <strong>YYYYMM</strong> por el año y el número de mes en el que estamos.</p>

<p><strong>SI NO, NO PINCHA</strong></p>

<p>A mi me quedó así:</p>

<pre><code class="cfg /etc/opendkim/key.table">tudominio     tudominio.cu:201606:/etc/opendkim/keys/example.private
</code></pre>

<p>Ya que estamos en el año <strong>2016</strong> y el mes <strong>0</strong>6 no el 6 (lleva cero delante).</p>

<p>Ojo aquí, ya que si tienes más dominios, es complicado. Nota que debes reflejar
a localhost con sus pertinentes ip, además, tu nombre de host, tu dominio y el
nombre del host conjugado con el dominio. Siendo entonces <strong>fulanito</strong> el nombre
del host, quedaría así en el fichero <strong>/etc/opendkim/trusted.hosts</strong></p>

<pre><code class="cfg /etc/opendkim/trusted.hosts">127.0.0.1
::1
localhost
fulanito
fulanito.dominio.cu
dominio.cu
</code></pre>

<p>Los permisos, ya tu sabes:</p>

<pre><code class="bash "seteando permisos"">chown -R opendkim:opendkim /etc/opendkim
chmod -R go-rwx /etc/opendkim/keys
</code></pre>

<p>FINALMENTE! Vamos a generar la clave para el dominio:</p>

<pre><code class="bash "generando las claves"">cd /etc/opendkim/keys/
opendkim-genkey -b 2048 -r -s 201606
</code></pre>

<p>Las claves se generan en base a la fecha, pero luego se colocan en base al
dominio. Esto se hace porque <strong>hay que renovarlos</strong> pero si configuramos
opendkim para que apunte a un fichero cuyo nombre sea la fecha, tendríamos que
cambiar la configuración cada vez que renovamos.</p>

<pre><code class="bash "la clave por su nombre"">mv 201606.private tudominio.private
mv 201606.txt tudominio.txt
</code></pre>

<p>Si tu clave se llamase &ldquo;pepe&rdquo; o &ldquo;midkim&rdquo;, ya sabes que esos ficheros se
llamarían &ldquo;pepe.private&rdquo; o &ldquo;tudkim.txt&rdquo; ¿Entiendes ahora? Seguimos&hellip;</p>

<p>El argumento <strong>-b</strong> indica la longitud de clave en Bit. En otros tiempo 1024 era
la tisa, pero ahora, se recomienda usar 2048 porque las máquinas son más
potentes. Quizás dentro de un par de años, sea 4096.</p>

<p>Bueno, ya sabes, la ceremonia de los permisos:</p>

<pre><code class="bash "seteando permisos"">chown -R opendkim:opendkim /etc/opendkim
chmod -R go-rw /etc/opendkim/keys
</code></pre>

<p>Arranca opendkim y asegúrate mirando los; log que esté pinchando.</p>

<pre><code class="bash "arranca opendkim"">systemctl restart opendkim
systemctl status -l opendkim
</code></pre>

<h2>El DNS</h2>

<p>   <blockquote><p>El patico feo de internet, el DNS. El remedio que se inventó pa ir tirando y acabó quedándose con su pésimo diseño y su horrible arquitectura que hasta el sol de hoy, pretende llamarse &ldquo;distribuida&rdquo;</p><footer><strong>Lázaro Armando</strong> <cite>Mi Criterio Sobre DNS</cite></footer></blockquote></p>

<p>Agregamos le registro TXT con la clave. Te cuento que el fichero &ldquo;.txt&rdquo; contiene
el tabaco base64 que usualmente vemos en el encabezado DKIM-Signature, pues
proviene de este registro TXT que estamos creando.</p>

<p>Añade un registro del tipo TXT que apunte a un hostname llamado
<strong>201606._domainkey</strong> dentro de tu domino. Pero ahora viene la parte difícil:</p>

<p>Copia <strong>el texto</strong> que contiene el fichero tudominio.txt dentro de la primera
comilla hasta la última, pero sin tomar las comillas.</p>

<p><strong>¿Se entendió?</strong></p>

<p>O sea, dentro del fichero tiene esto:</p>

<pre><code class="cfg "tudominio.txt"">201606._domainkey  IN  TXT ( "**v=DKIM1; k=rsa; s=email; " "p=ZjiONVGXom64jANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu5oIUrFDWZK7F4thFxpZa2or6jBEX3cSL6b2TJdPkO5iNn9vHNXhNX31nOefN8FksX94YbLJ8NHcFPbaZTW8R2HthYxRaCyqodxlLHibg8aHdfa+bxKeiI/xABRuAM0WG0JEDSyakMFqIO40ghj/h7DUc/4OXNdeQhrKDTlgf2bd+FjpJ3bNAFcMYa3Oeju33b2Tp+PdtqIwXR" "ZksfuXh7m30kuyavp3Uaso145DRBaJZA55lNxmHWMgMjO+YjNeuR6j4oQqyGwzPaVcSdOG8Js2mXt+J3Hr+nNmJGxZUUW4Uw5ws08wT9opRgSpn+ThX2d1AgQePpGrWOamC3PdcwIDAQAB**")  ; ----- DKIM key 201606 for tudominio.cu
</code></pre>

<p>Al extraer la parte que nos interesa, no quedamos con esto (sin las comillas)</p>

<pre><code class="cfg "la clave sin las comillas"">**v=DKIM1; k=rsa; s=email; p=ZJiONVGXom64zhNjwdAmo2XnMhAXeGXxB0p5PJkHxUk5XMXNaoUbMwfGOBOQYKsiQp0k9KwcYu2SNAlcFrGIugPG035Ng4r8mlBRLS5+dak90HuH+hb2d8aa+djRFn4PIS2RcAZZJgJjRgF1NbWZpBlj8IpXJ7MywrUxtj1e+TU/tCiWQxCc9uMqgWA53NeqRGEFPwCuTfDMKWbbMhZkbe+pOOtEqQBQ0HsvJ3n09ZNhh3AjbNP6JOpAyK+4hqHohDTrLhxdSFsNiaoAaJXsxDdAHIs2U3QNmrbAFEg7aPOBgaHLXv28k88EDqo4cIuOxa/c24e3F4O6TY3fpydRmekadtCW+waY3aCIIwIA7DdAABFUTR3ABI8WnFTjgDyj1/IQ53Af**
</code></pre>

<p><strong>OJO</strong> Tiene más comillas en el medio!!!!</p>

<p>Auxíliate de un editor de texto decente. Deshabilita el wrap y busca la comilla
como cadena de texto.</p>

<p>Ese texto, será el valor del puntero TXT</p>

<p>A mi me quedó así:</p>

<pre><code class="cfg "puntero TXT de 201606._domainkey"">201601._domainkey    IN      TXT     "**v=DKIM1; k=rsa; s=email; p=ZJiONVGXom64zhNjwdAmo2XnMhAXeGXxB0p5PJkHxUk5XMXNaoUbMwfGOBOQYKsiQp0k9KwcYu2SNAlcFrGIugPG035Ng4r8mlBRLS5+dak90HuH+hb2d8aa+djRFn4PIS2RcAZZJgJjRgF1NbWZpBlj8IpXJ7MywrUxtj1e+TU/tCiWQxCc9uMqgWA53NeqRGEFPwCuTfDMKWbbMhZkbe+pOOtEqQBQ0HsvJ3n09ZNhh3AjbNP6JOpAyK+4hqHohDTrLhxdSFsNiaoAaJXsxDdAHIs2U3QNmrbAFEg7aPOBgaHLXv28k88EDqo4cIuOxa/c24e3F4O6TY3fpydRmekadtCW+waY3aCIIwIA7DdAABFUTR3ABI8WnFTjgDyj1/IQ53Af**"
</code></pre>

<p>Completo! Vamos a probarlo a ver que pasa:</p>

<pre><code class="bash "1, 2, 3, probando"">opendkim-testkey -d example.com -s 201606
</code></pre>

<p>Si sale silentemente sin mostrar algo. Es que todo está bien.</p>

<h3>opendkim y postfix</h3>

<p>Finalmente, nuestro postfix tendrá el privilegio de firmar los correos usando el
aparataje recién configurado. Vamos a crearle un cuartico de dkim en la casa de
postfix</p>

<pre><code class="bash "dkim en postfix"">mkdir /var/spool/postfix/opendkim
chown opendkim:postfix /var/spool/postfix/opendkim
</code></pre>

<p>y habilitamos el socket de opendkim, editando el fichero <strong>/etc/default/opendkim</strong></p>

<pre><code class="cfg /etc/default/opendkim"># Command-line options specified here will override the contents of
# /etc/opendkim.conf. See opendkim(8) for a complete list of options.
#DAEMON_OPTS=""
#
# Uncomment to specify an alternate socket
# Note that setting this will override any Socket value in opendkim.conf
SOCKET="local:/var/spool/postfix/opendkim/opendkim.sock"
#SOCKET="inet:54321" # listen on all interfaces on port 54321
#SOCKET="inet:12345@localhost" # listen on loopback on port 12345
#SOCKET="inet:12345@192.0.2.1" # listen on 192.0.2.1 on port 12345
</code></pre>

<p>Note como retiramos el comentario de la línea 7</p>

<p>Ahora declaramos en postfix que debe usar a opendkim como demonio de
preprocesamiento en el típico <strong>/etc/postfix/main.cf</strong></p>

<pre><code class="cfg /etc/postfix/main.cf"># Milter configuration
# OpenDKIM
milter_default_action = accept
milter_protocol = 2
smtpd_milters = local:/opendkim/opendkim.sock
non_smtpd_milters = local:/opendkim/opendkim.sock
</code></pre>

<p>Finalmente, reinicia opendkim y postfix</p>

<pre><code class="bash "systemctl"">systemctl restart opendkim postfix
</code></pre>

<h3>COMPLETO!!!</h3>

<p>Con eso hemos terminado. Para probarlo, puede enviar un correo a <a href="mailto:check-auth@verifier.port25.com">check-auth@verifier.port25.com</a></p>

<p>Esa dirección le hará una prueba al DKIM+SPF de tu correo. No solo eso, le hará
una prueba del Pi al Pa a tu correo y te dirá todo lo que necesitas.</p>

<p>Si quieres ponerle la guinda al pastel, puede añadirle ADSP (Author Domain
Signing Practices) a tu esquema. Esto indica que todos los correos que salgan de
tu dominio deben estar firmados con DKIM, proveiendo aún más confianza al
receptor.</p>

<p>Crea un registro <strong>TXT</strong> para el hostname <strong><em>adsp.</em>domainkey</strong> y el valor del
TXT será <strong>dkim=all</strong>. A mi me quedó así:</p>

<pre><code class="cfg "registro"">_adsp._domainkey     IN      TXT     "dkim=all"
</code></pre>

<p>Con eso, tus correos no caerán más en la bandeja SPAM de gmail.</p>

<p>Otra cosa importante, asegúrate de tener el reverse lookup de tu MX bien puesto.</p>
]]></content>
  </entry>
  
</feed>
