<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: destacado | El SysAdmin del 3er Mundo]]></title>
  <link href="http://uranio-235.github.io/blog/categories/destacado/atom.xml" rel="self"/>
  <link href="http://uranio-235.github.io/"/>
  <updated>2015-11-19T13:24:46-05:00</updated>
  <id>http://uranio-235.github.io/</id>
  <author>
    <name><![CDATA[låzaro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[tls y ssl en postfix]]></title>
    <link href="http://uranio-235.github.io/blog/2015/11/03/tls-y-ssl-en-postfix/"/>
    <updated>2015-11-03T21:13:44-05:00</updated>
    <id>http://uranio-235.github.io/blog/2015/11/03/tls-y-ssl-en-postfix</id>
    <content type="html"><![CDATA[<p>Acá en salud, ahora <em>se están cayendo de la mata</em> y dándose cuenta de los
peligroso que son las conexiones planas.</p>

<p>Aún no logro hacerle entender a la gente, la diferencia entre un certificado
autofirmado y un certificado emitido por una <a href="https://es.wikipedia.org/wiki/Autoridad_de_certificaci%C3%B3n">autoridad de certificación</a>
; pero que más les vamos a pedir, si el certificado de nauta es autofirmado.</p>

<p>De momento con darle la muela del candadito y las letricas verdes en el
navegador, van cogiendo algo.</p>

<p>Pero volviendo al tema <strong>postfix con SSL</strong>. Vamos a crear un certificado
autofirmado, por tanto, regla de oro:</p>

<h4>el hostname que provees en el certificado, debe ser machear al del servicio</h4>

<p>En letra de molde. Si proveemos un certificado autofirmado, para conectarnos a
<strong>smtp.hcg.sld.cu</strong> no puedes decir en el cliente de correo, que el servidor
smtp es <strong>192.168.0.1</strong> porque no será válido.</p>

<p>Aún cuando el certificado no sea válido, déjame recodarte que debemos ir
haciéndole cultura de seguridad informática, si no&hellip; bueno&hellip; no me voy a meter
en un lío diciendo las barbaridades que se logran suplantando identidades.</p>

<p>Bueno entremos en materia. Lo Primero que haremos será generar la clave privada
para el servidor.</p>

<p>Donde dice <strong>smtp.tudominio.cu</strong> tu pondrás el hostname de que apunta para tu
servidor smtp. Si eres un desastre y no tiene DNS. Pon la IP de tu servidor de
correo.</p>

<h4>REPITO</h4>

<p>Donde dice <strong>FQDN or YOUR name</strong> debe decir la dirección del servidor SMTP. La
dirección tal cual la pones en los clientes.</p>

<p>Cuando lo hagas, te pedirá un password.</p>

<pre><code class="bash "generando clave privada del servidor"">openssl genrsa -des3 -out smtp.tudominio.cu.key 2048
</code></pre>

<p>Ahora creamos el certificado. Te pedirá hasta la talla de calzoncillos que usas.
<strong>NO respondas a lo locoi</strong>, recuerda el <strong>FQDN</strong>. Te acuerdas del password
que pusiste?</p>

<pre><code class="bash "creando el certificado"">openssl req -new -key smtp.tudominio.cu.key -out smtp.tudominio.cu.csr
</code></pre>

<p>Debes ver algo como esto:</p>

<pre><code class="bash "ceremonia de creación de certificado"">Enter pass phrase for smtp.tudominio.cu.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:CU
State or Province Name (full name) [Some-State]:Havana
Locality Name (eg, city) []:Plaza
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Calixto
Organizational Unit Name (eg, section) []:Informatica
Common Name (e.g. server FQDN or YOUR name) []:smtp.tudominio.cu
Email Address []:ssl@tudominio.cu
</code></pre>

<p>Bites verdad? Bueno, ya hicimos lo más importante, pero no hemos terminado.
Vamos a firmar el certificado con la la llave emisora.</p>

<pre><code class="bash "cri-cra firmando el certificado"">openssl x509 -req -days 365 -in smtp.tudominio.cu.csr -signkey smtp.tudominio.cu.key -out smtp.tudominio.cu.crt
</code></pre>

<p>Ahora vamos a dar un paso <strong>cuestionable</strong>.</p>

<p>Cada vez que un servicio con con un certificado SSL valla a ser iniciado.
Debería pedir un password, para así asegurar que el legítimo operador de
servicio ha sido quien le dio la arrancada. Pero poner un password cada vez que
arranca postfix, no es ninguna gracia. Por tanto, quitamos el password.
Obviamente, te lo pedirá una última vez.</p>

<pre><code class="bash "quitando el password"">openssl rsa -in smtp.tudominio.cu.key -out smtp.tudominio.cu.key.sinpassword
mv smtp.tudominio.cu.key.sinpassword smtp.tudominio.cu.key
</code></pre>

<p>Emitimos una autoridad de raíz (de pacotilla)</p>

<pre><code class="bash "la CA del chiste" ">openssl req -new -x509 -extensions v3_ca -keyout cakey.pem -out cacert.pem -days 3650
# aqui te pedirá la misma rutina, ojo con lo que pones en el campo FQDN or YOUR name
</code></pre>

<p>Bueno, con el disi y con el mulo, ya tenemos una CA loca, que la podemos reusar
para otros servicios, por tanto, tratemosla como tal.</p>

<pre><code class="bash "los puntos sobre las ies" ">chmod 600 smtp.tudominio.cu.key
chmod 600 cakey.pem
mv smtp.tudominio.cu.key /etc/ssl/private/
mv smtp.tudominio.cu.crt /etc/ssl/certs/
mv cakey.pem /etc/ssl/private/
mv cacert.pem /etc/ssl/certs/
</code></pre>

<p>Ahora viene el turno de postfix. Haremos dos cosas</p>

<ul>
<li>habilitar el tranporte ssl/tls por el puerto 465</li>
<li>habilitar las funciones ssl</li>
</ul>


<p>Ve al <strong>master.cf</strong> y busca la cadena de texto <strong>smtps</strong> debes ver algo como
esto:</p>

<pre><code class="bash "parte del master.cf ANTES"">smtp      inet  n       -       -       -       -       smtpd
#smtp      inet  n       -       -       -       1       postscreen
#smtpd     pass  -       -       -       -       -       smtpd
#dnsblog   unix  -       -       -       -       0       dnsblog
#tlsproxy  unix  -       -       -       -       0       tlsproxy
#submission inet n       -       -       -       -       smtpd
#  -o syslog_name=postfix/submission
#  -o smtpd_tls_security_level=encrypt
#  -o smtpd_sasl_auth_enable=yes
#  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
#  -o milter_macro_daemon_name=ORIGINATING
#smtps     inet  n       -       -       -       -       smtpd
#  -o syslog_name=postfix/smtps
#  -o smtpd_tls_wrappermode=yes
#  -o smtpd_sasl_auth_enable=yes
#  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
#  -o milter_macro_daemon_name=ORIGINATING
#628       inet  n       -       -       -       -       qmqpd
pickup    fifo  n       -       -       60      1       pickup
cleanup   unix  n       -       -       -       0       cleanup
</code></pre>

<p>Descomentamos todo lo que tenga que ver con <strong>smtps</strong> debe quedarte más o menos
así:</p>

<pre><code class="sh "parte del master.cf DESPUES"">smtp      inet  n       -       -       -       -       smtpd
#smtp      inet  n       -       -       -       1       postscreen
#smtpd     pass  -       -       -       -       -       smtpd
#dnsblog   unix  -       -       -       -       0       dnsblog
#tlsproxy  unix  -       -       -       -       0       tlsproxy
#submission inet n       -       -       -       -       smtpd
#  -o syslog_name=postfix/submission
#  -o smtpd_tls_security_level=encrypt
#  -o smtpd_sasl_auth_enable=yes
#  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
#  -o milter_macro_daemon_name=ORIGINATING
smtps     inet  n       -       -       -       -       smtpd
  -o syslog_name=postfix/smtps
  -o smtpd_tls_wrappermode=yes
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
  -o milter_macro_daemon_name=ORIGINATING
#628       inet  n       -       -       -       -       qmqpd
pickup    fifo  n       -       -       60      1       pickup
cleanup   unix  n       -       -       -       0       cleanup
</code></pre>

<p>Ahora trabajemos con el <strong>main.cf</strong>, habilitamos las funciones que tengan que
ver con SSL, declarando esto:</p>

<pre><code class="bash "tope del main.cf"">smtpd_use_tls = yes
smtpd_tls_auth_only = no
smtpd_tls_key_file = /etc/ssl/private/smtp.tudominio.cu.key
smtpd_tls_cert_file = /etc/ssl/certs/smtp.tudominio.cu.crt
smtpd_tls_CAfile = /etc/ssl/certs/cacert.pem
tls_random_source = dev:/dev/urandom
</code></pre>

<p>No olvides correr <strong>postfix reload</strong></p>

<p>   <blockquote><p>Te voy a coser el culo con un alambre finito.<br/>   No te quedará bonito, pero te quedará seguro.</p><footer><strong>Décima popular</strong></footer></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[repo de fdroid]]></title>
    <link href="http://uranio-235.github.io/blog/2015/10/15/repo-de-fdroid/"/>
    <updated>2015-10-15T14:38:20-04:00</updated>
    <id>http://uranio-235.github.io/blog/2015/10/15/repo-de-fdroid</id>
    <content type="html"><![CDATA[<p>&ldquo;La que se avecina&rdquo;, sería una buena manera para describir la revolución de
aparatos con android que habrá en el Calixto García muy pronto. Yo siempre con
el paso al frente y las luz larga (modestia y aparte) estuve pensando que tener
nuestro propio repositorio de aplicaciones para android; sería una buena manera
de mantener a todo el mundo bien actualizado, sobre todo a aquellos que no
tienen acceso a internet.</p>

<p>Para el que no lo conozca, <a href="https://f-droid.org/">fdroid</a> es una herramienta
cliente para repositorios de android, osea como google market pero libre.</p>

<p>La mecánica es sencilla: Bajo los paquetes con
<a href="http://www.aptoide.com">aptoide</a>, verifico que sean seguros y copio la cache
para el directorio repo/ de fdroid en el servidor con <a href="https://acrosync.com/">acrosync</a></p>

<p>En el repo de debian y en AUR, el paquete se llama <strong>fdroidserver</strong> la rutina de
instalación ya la conoces.</p>

<p>Creamos el directorio donde meteremos el repo, en mi caso, aquí:</p>

<pre><code class="bash mkdir">mkdir -p /srv/http/fdroid/repo
</code></pre>

<p>Creamos la configuración de nginx, a mi me quedó así:</p>

<pre><code class="bash nginx.conf">server {
     listen   10.1.1.14:80;
     listen   10.1.1.14:443 ssl;
     server_name android.hcg.sld.cu;
     location / {
     root /srv/http/fdroid/repo/;
     }
}
</code></pre>

<p>Un virtualhost nombrado <em>android</em>. <strong>No olvide crear el puntero DNS</strong></p>

<p>Ahora, ve al directorio raíz del repo, OJO <strong>A LA RAIZ</strong>, NO a donde dice repo/.</p>

<pre><code class="bash fdroid">cd /srv/http/fdroid/
fdroid init
</code></pre>

<p>Te preguntará por la <strong>android-sdk</strong>, por lo general, está en /opt/android-sdk,
dale la ruta.</p>

<p>¿¿No tienes la SDK de android?? Ah pues estás muy jodio&hellip; En el caso de arch,
el repo de bbqlinux contiene la sdk completa, solo para 64 bits.</p>

<p>Pero volviendo con fdroid:</p>

<p>Ahora debe habérse creado el directorio <strong>repo/</strong> dentro del directorio
<strong>/srv/http/fdroid</strong> y es ahí donde copiarás las APK.</p>

<p>cp /donde/esten/tus/*.apk /srv/http/fdroid/<strong>repo/</strong></p>

<p>Pero claro, querrás que tu repo se identifique.  El fichero
<strong>/srv/http/fdroid/config.py</strong> contiene lo que buscas. Por la linea trenta y
pico; a mi me quedó así:</p>

<pre><code class="python config.py">...

repo_url = "http://android.hcg.sld.cu"
repo_name = "Calixto Garcia"
repo_icon = "calixto_xsm.png"
repo_description = """
Repositorio de aplicaciones de android del calixto. Intentaremos proveerle
aplicaciones debidamente actualizadas. Sientase libre de colaborar, trayendonos
las mas recientes APK.
"""

...
</code></pre>

<p>Ah! y sin tildes, si no, python se vuelve loco con el encoding.</p>

<p>Ahora vamos a crear el índice inicial, pero eso mismo comando lo correrás cuando
agregues aplicaciones a tu repo.</p>

<pre><code class="bash fdroid">fdroid update --create-metadata
</code></pre>

<p>OJO!! Asegúrate de que las APK no tengan un espacio en su nombre; muchísimo
menos un caracter raro. Si todo salió bien debes ver algo como &ldquo;Generating
metada&rdquo;.</p>

<p>Con eso terminaste el servidor&hellip; Ve a fdroid y ponle la URL del virtualhost
como repo, luego update y listo&hellip;</p>

<p>¿Cómo se hace? Facilito. Párate en la primer pantalla, aprieta el botón de menú
del dispositivo y toca donde dice &ldquo;Gestionar Repositorios&rdquo; o en inglés, &ldquo;Manage
Repos&rdquo;</p>

<p>Desactiva los respos inalcanzables y añade tu repo local. Luego actualiza y
listo, verás las aplicaciones disponibles.</p>

<p>Ya solo te quedaría instalar un rsync que desemboque en el repo y con
<a href="https://acrosync.com/">acrosync</a> subes la cache de aptotide para el repo, así
como estoy haciendo yo ahora.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux con dos kernel]]></title>
    <link href="http://uranio-235.github.io/blog/2015/09/07/archlinux-dos-kernel/"/>
    <updated>2015-09-07T20:32:57-04:00</updated>
    <id>http://uranio-235.github.io/blog/2015/09/07/archlinux-dos-kernel</id>
    <content type="html"><![CDATA[<p>Tener los dos kernel y elegir cual butear con el grub al principio; no es algo
sencillo en archlinux.</p>

<p>Por defecto, el grub dice tener dichas entradas en un submenú que nunca se ve.
Para lograrlo, tenemos que hacer unos paces mágicos en el fichero:</p>

<h4>/etc/default/grub</h4>

<p>Primero instalamos los kernels; el lts y el fresco.</p>

<pre><code class="bash "los kernels"">pacman -S linux linux-lts
</code></pre>

<p>Ahora la configuración con la que logré eso, fue agregándole al final estas
lineas:</p>

<pre><code class="bash "/etc/default/grub"">GRUB_DISABLE_SUBMENU=y
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT=true
</code></pre>

<p>Con eso, se salva la última entrada ejecutada. Por que, lo más obvio, es que la
próxima vez que arranques, se cargue el último kernel que usaste. Lo inusual
sería que cambies de opinión y cargues otro. Desgraciadamente, si como yo, usas
btrfs como sistema de archivo, grub no podrá escribir el fichero con la última
entrada seleccionada. Incluso te dará un error, diciendo que no puede escribir
el fichero no se que.</p>

<p>Seguimos&hellip; Localiza y la linea de recovery y ponla en false:</p>

<pre><code class="bash "/etc/default/grub""># Uncomment to disable generation of recovery mode menu entries
GRUB_DISABLE_RECOVERY=false
</code></pre>

<p><strong>NO SE POR QUE</strong>, pero no se generan las dichosas entradas si eso no está en
false. Además, tener el menú de recovery es bastante útil, en estas distros
volátiles, uno nunca sabe cuando le va a hacer falta.</p>

<p>Paso final, generar el grub.cfg</p>

<pre><code class="bash "grub-mkconfig"">grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>

<p>Va y si quieres, no es obligado, pero para probar, <strong>REINICIA</strong>.</p>

<p>   <blockquote><p>Prefiero lidiar con las pifias de una comunidad<br/>   que con las mazmorras de una compañía.</p><footer><strong>Lázaro Armando</strong></footer></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[compute remote uptime]]></title>
    <link href="http://uranio-235.github.io/blog/2015/08/28/compute-remote-uptime/"/>
    <updated>2015-08-28T12:21:58-04:00</updated>
    <id>http://uranio-235.github.io/blog/2015/08/28/compute-remote-uptime</id>
    <content type="html"><![CDATA[<p>Vamos de atrás pa alante, el truco primero y la muela después.</p>

<pre><code class="bash "nmap"">[root@artema ~]# nmap -O -v 10.1.1.1|grep -i uptime
Uptime guess: 18.006 days (since Fri Aug 10 12:24:47 2015)
</code></pre>

<h4>¿Que acaba de suceder?</h4>

<p>Calculamos el tiempo que lleva el servidor remoto en pie. Fíjese que nos dice la
fecha en la que el servidor arrancó.</p>

<h4>¿Para que sirve esta información?</h4>

<p>Para poner al responsable de la computadora remota <em>contra las cuerdas</em> en una
situación crítica donde el momento de encendido o apagado de la máquina podría
ser crucial.</p>

<h4>Ejemplos:</h4>

<p>Nuestro proveedor, el servidor proxy padre, afirma descaradamente que NO ha
tenido problemas técnicos, pero nosotros sabemos que sí. En una discución
crucial podría dejarle caer la pregunta. <em>¿Entonces porque su servidor se
reinició el día tal?</em></p>

<p>Un servicio determinado falla a una hora determinada de la noche. Con esto
podríamos saber si el servidor se está reiniciando, cuando y con que frecuencia.</p>

<p>El proveedor dice que ha tenido que reiniciar el servidor cuando en realidad
nunca lo ha hecho.</p>

<p>El usuario dice que la máquina se le reinicia constantemente.</p>

<p>El usuario o el proveedor afirman que la máquina fue encendida a una hora
determinada. O por el contrario, se afirma que la máquina a esa hora NO estaba
encendida y el uptime dice lo contrario.</p>

<p>   <blockquote><p>Saque usted, sus propias concluciones&hellip;</p><footer><strong>Taladrid</strong> <cite>Pasaje a Lo Desconocido</cite></footer></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenVAS en Archlinux]]></title>
    <link href="http://uranio-235.github.io/blog/2015/07/11/openvas-en-archlinux/"/>
    <updated>2015-07-11T19:19:59-04:00</updated>
    <id>http://uranio-235.github.io/blog/2015/07/11/openvas-en-archlinux</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/greenbone.png" title="&ldquo;Login del Greenbone&rdquo; &ldquo;Login del Greenbone&rdquo;" ></p>

<p>Recientemente, un &ldquo;Webmaster&rdquo; usó en uno de los servidores que patrocino; un
escaner de vulnerabilidades. El administrador de red del lugar, le dio acceso al
servidor; claro está. El informe reveló un cartapaso de vulnerabilidades. Por
ejemplo, la ausencia de una partición swap; podría dar lugar a un kernel-panic
por falta de memoria RAM; en un servidor de correo con 4 Gigas de RAM. Además,
advertía que la versión de bash (con sus parches puestos) era muy vieja y
recomendaba usar una reciente. Como si instalar software reciente en debian
fuese jamón.</p>

<p>No vi nada con respecto a postfix o dovecot pero de inmediato me llamaron para
que explicara como era posible que mi servidor tuviera semejantes
vulnerabilidades. Claro, con acceso a root cualquiera busca vulnerabilidades.</p>

<p>Soy de los que pasa HORAS, intentando penetrar mi propia seguridad; pero el caso
llevaba un contra ataque más elaborado.</p>

<p>El sosftware por excelencia para probar la seguridad: <a href="http://es.wikipedia.org/wiki/OpenVAS">OpenVAS</a></p>

<h3>No solo identifica el problema, también te dice como arreglarlo.</h3>

<p>Funciona de manera similar a un antivirus. Una base de datos se actualiza y ala
las vulnerabilidades conocidas. Luego, una interfaz web, de lo más cómoda;
permite llevar a cabo un análisis tanto ligero como exhaustivo del sistema
seleccionado como objetivo. Además, se pueden programar análisis de manera
automatizada.</p>

<p>Su interfaz web, el llamado &ldquo;Greenbone Security Assistant&rdquo;, nos hará la vida muy
fácil una vez instalado.</p>

<p>En archlinux todo es un rollo, así que empezemos:</p>

<pre><code class="bash "instalando openvas"">pacman -S openvas
</code></pre>

<p>La interfaz web de openvas (el greenbone) debe ser contactada por SSL (obligao).
Como siempre, crear los certificados es todo una ceremonia.</p>

<pre><code class="bash "creando certificados"">openvas-mkcert
openvas-mkcert-client -n -i
</code></pre>

<p>Ahora lo más importante. Descargarnos la base de datos con las amenazas, o sea,
con las vulnerabilidades.</p>

<pre><code class="bash "actualizando las bases"">openvas-nvt-sync
openvas-scapdata-sync
openvas-certdata-sync
</code></pre>

<p>El escaner, es un servicio, que en producción, está supuestamente corriendo y
realizando escaneos bajo demanda. Lo echamos a andar:</p>

<pre><code class="bash "el servicio"">systemctl start openvas-scanner
</code></pre>

<p>Una vez que tenemos las bases de datos descargadas, las instalamos en openvas</p>

<pre><code class="bash "instalando las bases"">openvasmd --rebuild --progress
</code></pre>

<p>Y hasta aquí es donde la wiki de arch está bien. Pues para crear el usuario de
openvas y echar a andar el greenbone, se forma la moña.</p>

<p>Primero debemos crear el usuario de openvas. En este caso de ejemplo, el
usuario será <strong>admin</strong> con password <strong>admin</strong>.</p>

<pre><code class="bash "creando usuarios"">openvasmd --create-user=admin --role=Admin
openvasmd --user=admin --new-password=admin
</code></pre>

<p>Por último, echamos a andar la interfaz web:</p>

<pre><code class="bash "iniciando gsad"">gsad --http-only --listen=127.0.0.1 -p 9392
openvasmd -p 9390 -a 127.0.0.1
</code></pre>

<p>Abre un navegador y apunta para <a href="http://127.0.0.1:9392">http://127.0.0.1:9392</a></p>

<p>Una vez dentro, verás la página donde se almacenan los escaneos. Ahí localiza un
botón morado con una barita mágica. Vea la imagen de abajo</p>

<p><img class="center" src="/images/openvas_wiz.png" title="&ldquo;Botón del Wizard&rdquo; &ldquo;Botón del Wizard&rdquo;" ></p>

<p>En la pantalla que le sigue, especificamos el host al que queremos escanear.</p>

<p><img class="center" src="/images/openvas_scan.png" title="&ldquo;Seleccionar Objetivo&rdquo; &ldquo;Seleccionar objetivo&rdquo;" ></p>

<p>Apto seguido, comenzará el escaneo. Es posible que el servidor deje de prestar
servicios; pues openvas le da con todo.</p>

<p>Finalmente, cuando el escaneo esté terminado, en vez de un tanto por ciento,
verás; como en la primera imagen, un letrero que dice &ldquo;<strong>done</strong>&rdquo; sobre la barra
azul.</p>

<p><img class="center" src="/images/openvas_result.png" title="&ldquo;resultado del escaneo&rdquo; &ldquo;resultado de escaneo&rdquo;" ></p>

<p>La imagen muestra, el resultado del webmaster que le tiró piedras al tejado del
vecino con el suyo de vidrio. Al hacer click en la vulnerabilidad, nos muestra
la solución, como es el ejemplo de esta:</p>

<p><img class="center" src="/images/openvas_sol.png" title="&ldquo;solución&rdquo; &ldquo;solución&rdquo;" ></p>

<p>Hermosa pareja; el problema y la solución junticos&hellip;</p>
]]></content>
  </entry>
  
</feed>
