<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: destacado | El SysAdmin del 3er Mundo]]></title>
  <link href="http://uranio-235.github.io/blog/categories/destacado/atom.xml" rel="self"/>
  <link href="http://uranio-235.github.io/"/>
  <updated>2016-11-20T18:04:41-05:00</updated>
  <id>http://uranio-235.github.io/</id>
  <author>
    <name><![CDATA[låzaro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[dkim y spf en postfix]]></title>
    <link href="http://uranio-235.github.io/blog/2016/06/18/dkim-y-spf-en-postfix/"/>
    <updated>2016-06-18T13:57:51-04:00</updated>
    <id>http://uranio-235.github.io/blog/2016/06/18/dkim-y-spf-en-postfix</id>
    <content type="html"><![CDATA[<p>Aunque no de mi agrado, reconozco que es una solución muy buena. DKIM y SPF, se
ha vuelto hoy en día un mecanismo para mitigar el SPAM en el correo electrónico.</p>

<p>Esto no quita, que un spammer puede hacerse con un buen esquema de DKIM para sus
dominos de porquería; lo cual sería un estupendo negocio, teniendo en cuenta que
un servidor puede tener tantos dominios como quiera. Si conoce a algún spammer
que quiera tener DKIM y SPF en su negocio, por favor, mándele mi tarjeta.</p>

<p>Me imagino que a los usuarios de nauta, les duela bajar un mensaje que
aparentemente tiene dos lineas, pagando por uno que realmente tiene más de 20
líneas de pura mierda que no les incumbe. Espero que etecsa se digne a retirar
encabezados innecesarios como esos (para el cliente).</p>

<p>Por otra parte, mucha gente tiene antivirus que modifican el correo o son
fanáticos a instalar mil gangarreas (mailscanner, clamav, etc&hellip;) que también
modifican el correo. Con esto, DKIM y SPF <strong>se van a la mierda</strong>.</p>

<p>Le diré que hice con un postfix que ya estaba instalado en un debian8 para
ponerle DKIM y SPF.</p>

<p>Instalamos los jueguetes requeridos ante todo:</p>

<pre><code class="bash">apt-get install opendkim opendkim-tools postfix-policyd-spf-python
</code></pre>

<p>y establecemos los permisos adecuados, ojo con esto, ya que dkim es muy riguroso
con el tema de los permisos</p>

<pre><code class="bash">adduser postfix opendkim
</code></pre>

<h2>SPF</h2>

<p>Ahora procedemos a crear el registro DNS. Como hay muchos DNS y cada quién tiene
sus preferencias, me reduciré a describir de manera abstracta los registros.
Usted, aterrize la idea en su DNS.</p>

<h3>Esto tiene <strong>DOS</strong> formas de hacerse:</h3>

<h4>La primera:</h4>

<p>Declarar que TODOS los <strong>MX</strong> del dominio, pueden mandar correo (lo cual
inspira desconfianza) en este caso, registra un puntero del tipo <strong>TXT</strong> con el
siguiente valor</p>

<pre><code>v=spf1 mx -all
</code></pre>

<p>Por ejemplo, bind9</p>

<pre><code class="cfg "registro"">@               IN      TXT     "v=spf1 mx -all"
</code></pre>

<h4>La segunda:</h4>

<p>Declarar que un host, que tiene un registro <strong>A</strong>, está autorizado a enviar
correos (esta me gusta más, si tienes un solo servidor de correo) Si fueran
varios, por ejemplo 3. Podrías declarar un A para cada uno y de manera
individual, ellos generarían su SPF apuntándose a si mismo.</p>

<pre><code>v=spf1 a:mx1.tudominio.cu -all
</code></pre>

<p>Como ya sabemos, un puntero MX siempre deberá apuntar a un rgistro A, ya que no
se recomienda apuntar a un CNAME&hellip;</p>

<p><strong>Nota para los apurados:</strong> &ldquo;Si declaras ambos registros, no pincha, LEE!!&rdquo;</p>

<p>Otra cosa, puedes declarar <strong>-all</strong> o <strong>~all</strong> El primero le dirá al receptor
que si el correo no viene del dominio que dice enviarlo (el puntero A o los MX),
lo rechace porque es falso (muy radical) y el segundo, que empieza por ~ le
indica al receptor, que puede recibir el mensaje y si no pude verificarlo que lo
marque como spam, pero que por favor, no lo rechaze.</p>

<p>Esto nos lleva a una:</p>

<h3>Situación peligrosa</h3>

<p>Cuba, un descerebrado configuró verificación de DKIM, <strong>porque está de moda</strong>.
PERO! Está detrás de un smarthost (pasarela) o simplemente, su configuración de
DNS no vale un quilo (por culpa del proveedor)</p>

<p>Metedura de pata - A:</p>

<p>Ese servidor de correo, que se cree <em>Oggun con machete en mano</em>; descartará todo
correo con <strong>-all</strong> debido a su incapacidad de realizar un lookup decente.</p>

<p>Metedura de pata - B:</p>

<p>Uno más descerebrado todavía, vio que DKIM estaba de moda y sin importar que no
tiene control de su DNS, lo hizo todo, saltándose el paso del DNS. Su servidor
le estará gritando a toda voz al mundo entero, <strong>que está falseando el dominio</strong></p>

<p>Su ignorancia le costará caer de cabeza en las listas negras&hellip;</p>

<p>Y es que:</p>

<p>Generalmente, los servidores que entregan a través de un smarthost, carecen de
DNS real. También hay una pila de gente que administran servidores sin tener
control de su DNS.</p>

<h4>Seguimos&hellip;</h4>

<p>Ya que tenemos el SPF pinchando, podemos añadirle chequeo de SPF a nuestro
postfix <strong>que tiene bien configurado el DNS y entrega de cara a internet sin
smarthost</strong></p>

<p>En el fichero <strong>/etc/postfix/master.cf</strong> le agregamos esto:</p>

<pre><code class="cfg master.cf">policyd-spf  unix  -       n       n       -       0       spawn
    user=policyd-spf argv=/usr/bin/policyd-spf
</code></pre>

<p>y a los posftfix cubanos, le decimos que sea paciente con el proceso de
verificación, incrementando el tiempo que tiene que esperar por el policyd, ya
que dicha verificación puede tardar (dns lookup, cpu a tope, etc..) Añadimos
esto a <strong>/etc/postfix/main.cf</strong></p>

<pre><code class="cfg main.cf">policyd-spf_time_limit = 3600
</code></pre>

<p>Ahora viene una parte complicada, pues no hay manera de que pueda reflejarla
como para copiar y pegar.</p>

<p>Deberás modificar tus reglas de postfix, de forma que antepongas el chequeo SPF,
como una más de tus restricciones de recibo. Para mi caso, está bien la última
linea.</p>

<pre><code class="cfg "scpe del main.cf"">
smtpd_sender_restrictions =
   reject_non_fqdn_sender,
   reject_non_fqdn_recipient,
   permit_sasl_authenticated,
   reject_unknown_sender_domain,
   reject_unknown_recipient_domain,
   reject_rbl_client bl.spamcop.net,
   reject_rbl_client sbl.spamhaus.org,
   reject_rbl_client xbl.spamhaus.org,
   defer_unauth_destination,
   reject_unverified_sender,
   check_policy_service unix:private/policyd-spf
</code></pre>

<p>Reinicia postfix y chequea el <strong>/var/log/mail.log</strong> para que veas SPF pinchando.</p>

<h2>DKIM</h2>

<p>Me parece que la configuración de DKIM en debian está buena, pero por si las
moscas. Copias esta que pongo aquí y métela en tu <strong>/etc/opendkim.conf</strong></p>

<pre><code class="cfg /etc/opendkim.conf">Syslog          yes
UMask           002
UserID          opendkim
KeyTable        /etc/opendkim/key.table
SigningTable        refile:/etc/opendkim/signing.table
ExternalIgnoreList  /etc/opendkim/trusted.hosts
InternalHosts       /etc/opendkim/trusted.hosts
Canonicalization    relaxed/simple
Mode            sv
SubDomains      no
#ADSPAction     continue
AutoRestart     yes
AutoRestartRate     10/1M
Background      yes
DNSTimeout      5
SignatureAlgorithm  rsa-sha256
OversignHeaders     From
</code></pre>

<p>De ahí puede que quizás te interese la variables <strong>SubDomains</strong>, sobre todo si
eres proveedor de correo.</p>

<p>Como ya te dije, los permisos son sumamente importantes en este caso</p>

<pre><code class="bash permisos">chmod u=rw,go=r /etc/opendkim.conf
</code></pre>

<p>Ahora creamos el directorio donde vamos a meter todo el zoológico requerido para
que DKIM pinche. Hay quién prefiere meterlo en <strong>/var</strong>, para mi en
<strong>/etc/opendkim</strong> es un buen lugar.</p>

<pre><code class="bash "creando el directorio de residencia"">mkdir /etc/opendkim
mkdir /etc/opendkim/keys
chown -R opendkim:opendkim /etc/opendkim
chmod go-rw /etc/opendkim/keys
</code></pre>

<h3>La Firma</h3>

<p>Ahora vamos a crear la <em>tabla de rúbricas</em> (se aceptan contribuciones para
traducir). Ahí, ponemos una linea por cada dominio que tengas. Creas el fichero
<strong>/etc/opendkim/signing.table</strong> y está recomendado que le pongas lo siguiente:</p>

<pre><code class="cfg "como dicen que debe ser"">   *@tudominio.cu   tudominio
</code></pre>

<p><strong>Nota para los imbéciles:</strong> No olvide remplazar <em>tudominio.cu</em> por el nombre
del dominio suyo.</p>

<p>Con eso, casamos todos los correos que parezcan a tu dominio, con el DKIM que
llamamos &ldquo;tudominio&rdquo;, si quiere atrás le puede poner &ldquo;pepe&rdquo;. Lo que debe
quedarte claro, es que todos los correos que macheen a la expresión regular de
alante, pasarán por el filtro llamado <em>tudominio</em> (o &ldquo;pepe&rdquo; si lo cambiaste) ¿Se
entendió?</p>

<p>Por ejemplo, si tu dominio fuera *@cacocum.hlg.sld.cu podrías ponerle detrás
&ldquo;midkim&rdquo; para que todos los correos de ese dominio, se firmen con la firma que
será configurada bajo el nombre &ldquo;midkim&rdquo; Quedaría así:</p>

<pre><code>  *@cacocum.hlg.sld.cu  midkim
</code></pre>

<p>Resumen:</p>

<p>El primero campo, es una expresión regular que mache las direcciones de correo y
el segundo el nombre de la firma que se usará. Para mayor confusión, se
recomienda que se hagan nombres parecidos. Finalmente nos quedó así:</p>

<pre><code class="cfg /etc/opendkim/signing.table">*@tudominio.cu    tudominio
</code></pre>

<h3>La clave</h3>

<p>Ahora creamos el fichero, donde le diremos a &ldquo;midkim&rdquo; donde va a encontrar su
parafernalia cifradora. Crea el fichero <strong>/etc/opendkim/key.table</strong> y ponle
dentro esto:</p>

<pre><code class="cfg /etc/opendkim/key.table">tudominio     tudominio.cu:YYYYMM:/etc/opendkim/keys/example.private
</code></pre>

<p><strong>IMPORTANTE</strong></p>

<p>Remplaza <strong>YYYYMM</strong> por el año y el número de mes en el que estamos.</p>

<p><strong>SI NO, NO PINCHA</strong></p>

<p>A mi me quedó así:</p>

<pre><code class="cfg /etc/opendkim/key.table">tudominio     tudominio.cu:201606:/etc/opendkim/keys/example.private
</code></pre>

<p>Ya que estamos en el año <strong>2016</strong> y el mes <strong>0</strong>6 no el 6 (lleva cero delante).</p>

<p>Ojo aquí, ya que si tienes más dominios, es complicado. Nota que debes reflejar
a localhost con sus pertinentes ip, además, tu nombre de host, tu dominio y el
nombre del host conjugado con el dominio. Siendo entonces <strong>fulanito</strong> el nombre
del host, quedaría así en el fichero <strong>/etc/opendkim/trusted.hosts</strong></p>

<pre><code class="cfg /etc/opendkim/trusted.hosts">127.0.0.1
::1
localhost
fulanito
fulanito.dominio.cu
dominio.cu
</code></pre>

<p>Los permisos, ya tu sabes:</p>

<pre><code class="bash "seteando permisos"">chown -R opendkim:opendkim /etc/opendkim
chmod -R go-rwx /etc/opendkim/keys
</code></pre>

<p>FINALMENTE! Vamos a generar la clave para el dominio:</p>

<pre><code class="bash "generando las claves"">cd /etc/opendkim/keys/
opendkim-genkey -b 2048 -r -s 201606
</code></pre>

<p>Las claves se generan en base a la fecha, pero luego se colocan en base al
dominio. Esto se hace porque <strong>hay que renovarlos</strong> pero si configuramos
opendkim para que apunte a un fichero cuyo nombre sea la fecha, tendríamos que
cambiar la configuración cada vez que renovamos.</p>

<pre><code class="bash "la clave por su nombre"">mv 201606.private tudominio.private
mv 201606.txt tudominio.txt
</code></pre>

<p>Si tu clave se llamase &ldquo;pepe&rdquo; o &ldquo;midkim&rdquo;, ya sabes que esos ficheros se
llamarían &ldquo;pepe.private&rdquo; o &ldquo;tudkim.txt&rdquo; ¿Entiendes ahora? Seguimos&hellip;</p>

<p>El argumento <strong>-b</strong> indica la longitud de clave en Bit. En otros tiempo 1024 era
la tisa, pero ahora, se recomienda usar 2048 porque las máquinas son más
potentes. Quizás dentro de un par de años, sea 4096.</p>

<p>Bueno, ya sabes, la ceremonia de los permisos:</p>

<pre><code class="bash "seteando permisos"">chown -R opendkim:opendkim /etc/opendkim
chmod -R go-rw /etc/opendkim/keys
</code></pre>

<p>Arranca opendkim y asegúrate mirando los; log que esté pinchando.</p>

<pre><code class="bash "arranca opendkim"">systemctl restart opendkim
systemctl status -l opendkim
</code></pre>

<h2>El DNS</h2>

<p>El patico feo de internet, el DNS. El remedio que se inventó pa ir tirando y
acabó quedándose con su pésimo diseño y su horrible arquitectura que hasta el
sol de hoy, pretende llamarse &ldquo;distribuida&rdquo;.</p>

<p>Agregamos le registro TXT con la clave. Te cuento que el fichero &ldquo;.txt&rdquo; contiene
el tabaco base64 que usualmente vemos en el encabezado DKIM-Signature, pues
proviene de este registro TXT que estamos creando.</p>

<p>Añade un registro del tipo TXT que apunte a un hostname llamado
<strong>201606._domainkey</strong> dentro de tu domino. Pero ahora viene la parte difícil:</p>

<p>Copia <strong>el texto</strong> que contiene el fichero tudominio.txt dentro de la primera
comilla hasta la última, pero sin tomar las comillas.</p>

<p><strong>¿Se entendió?</strong></p>

<p>O sea, dentro del fichero tiene esto:</p>

<pre><code class="cfg "tudominio.txt"">201606._domainkey  IN  TXT ( "**v=DKIM1; k=rsa; s=email; " "p=ZjiONVGXom64jANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu5oIUrFDWZK7F4thFxpZa2or6jBEX3cSL6b2TJdPkO5iNn9vHNXhNX31nOefN8FksX94YbLJ8NHcFPbaZTW8R2HthYxRaCyqodxlLHibg8aHdfa+bxKeiI/xABRuAM0WG0JEDSyakMFqIO40ghj/h7DUc/4OXNdeQhrKDTlgf2bd+FjpJ3bNAFcMYa3Oeju33b2Tp+PdtqIwXR" "ZksfuXh7m30kuyavp3Uaso145DRBaJZA55lNxmHWMgMjO+YjNeuR6j4oQqyGwzPaVcSdOG8Js2mXt+J3Hr+nNmJGxZUUW4Uw5ws08wT9opRgSpn+ThX2d1AgQePpGrWOamC3PdcwIDAQAB**")  ; ----- DKIM key 201606 for tudominio.cu
</code></pre>

<p>Al extraer la parte que nos interesa, no quedamos con esto (sin las comillas)</p>

<pre><code class="cfg "la clave sin las comillas"">**v=DKIM1; k=rsa; s=email; p=ZJiONVGXom64zhNjwdAmo2XnMhAXeGXxB0p5PJkHxUk5XMXNaoUbMwfGOBOQYKsiQp0k9KwcYu2SNAlcFrGIugPG035Ng4r8mlBRLS5+dak90HuH+hb2d8aa+djRFn4PIS2RcAZZJgJjRgF1NbWZpBlj8IpXJ7MywrUxtj1e+TU/tCiWQxCc9uMqgWA53NeqRGEFPwCuTfDMKWbbMhZkbe+pOOtEqQBQ0HsvJ3n09ZNhh3AjbNP6JOpAyK+4hqHohDTrLhxdSFsNiaoAaJXsxDdAHIs2U3QNmrbAFEg7aPOBgaHLXv28k88EDqo4cIuOxa/c24e3F4O6TY3fpydRmekadtCW+waY3aCIIwIA7DdAABFUTR3ABI8WnFTjgDyj1/IQ53Af**
</code></pre>

<p><strong>OJO</strong> Tiene más comillas en el medio!!!!</p>

<p>Auxíliate de un editor de texto decente. Deshabilita el wrap y busca la comilla
como cadena de texto.</p>

<p>Ese texto, será el valor del puntero TXT</p>

<p>A mi me quedó así:</p>

<pre><code class="cfg "puntero TXT de 201606._domainkey"">201601._domainkey    IN      TXT     "**v=DKIM1; k=rsa; s=email; p=ZJiONVGXom64zhNjwdAmo2XnMhAXeGXxB0p5PJkHxUk5XMXNaoUbMwfGOBOQYKsiQp0k9KwcYu2SNAlcFrGIugPG035Ng4r8mlBRLS5+dak90HuH+hb2d8aa+djRFn4PIS2RcAZZJgJjRgF1NbWZpBlj8IpXJ7MywrUxtj1e+TU/tCiWQxCc9uMqgWA53NeqRGEFPwCuTfDMKWbbMhZkbe+pOOtEqQBQ0HsvJ3n09ZNhh3AjbNP6JOpAyK+4hqHohDTrLhxdSFsNiaoAaJXsxDdAHIs2U3QNmrbAFEg7aPOBgaHLXv28k88EDqo4cIuOxa/c24e3F4O6TY3fpydRmekadtCW+waY3aCIIwIA7DdAABFUTR3ABI8WnFTjgDyj1/IQ53Af**"
</code></pre>

<p>Completo! Vamos a probarlo a ver que pasa:</p>

<pre><code class="bash "1, 2, 3, probando"">opendkim-testkey -d example.com -s 201606
</code></pre>

<p>Si sale silentemente sin mostrar algo. Es que todo está bien.</p>

<h3>opendkim y postfix</h3>

<p>Finalmente, nuestro postfix tendrá el privilegio de firmar los correos usando el
aparataje recién configurado. Vamos a crearle un cuartico de dkim en la casa de
postfix</p>

<pre><code class="bash "dkim en postfix"">mkdir /var/spool/postfix/opendkim
chown opendkim:postfix /var/spool/postfix/opendkim
</code></pre>

<p>y habilitamos el socket de opendkim, editando el fichero <strong>/etc/default/opendkim</strong></p>

<pre><code class="cfg /etc/default/opendkim"># Command-line options specified here will override the contents of
# /etc/opendkim.conf. See opendkim(8) for a complete list of options.
#DAEMON_OPTS=""
#
# Uncomment to specify an alternate socket
# Note that setting this will override any Socket value in opendkim.conf
SOCKET="local:/var/spool/postfix/opendkim/opendkim.sock"
#SOCKET="inet:54321" # listen on all interfaces on port 54321
#SOCKET="inet:12345@localhost" # listen on loopback on port 12345
#SOCKET="inet:12345@192.0.2.1" # listen on 192.0.2.1 on port 12345
</code></pre>

<p>Note como retiramos el comentario de la línea 7</p>

<p>Ahora declaramos en postfix que debe usar a opendkim como demonio de
preprocesamiento en el típico <strong>/etc/postfix/main.cf</strong></p>

<pre><code class="cfg /etc/postfix/main.cf"># Milter configuration
# OpenDKIM
milter_default_action = accept
milter_protocol = 2
smtpd_milters = local:/opendkim/opendkim.sock
non_smtpd_milters = local:/opendkim/opendkim.sock
</code></pre>

<p>Finalmente, reinicia opendkim y postfix</p>

<pre><code class="bash "systemctl"">systemctl restart opendkim postfix
</code></pre>

<h3>COMPLETO!!!</h3>

<p>Con eso hemos terminado. Para probarlo, puede enviar un correo a <a href="mailto:check-auth@verifier.port25.com">check-auth@verifier.port25.com</a></p>

<p>Esa dirección le hará una prueba al DKIM+SPF de tu correo. No solo eso, le hará
una prueba del Pi al Pa a tu correo y te dirá todo lo que necesitas.</p>

<p>Si quieres ponerle la guinda al pastel, puede añadirle ADSP (Author Domain
Signing Practices) a tu esquema. Esto indica que todos los correos que salgan de
tu dominio deben estar firmados con DKIM, proveiendo aún más confianza al
receptor.</p>

<p>Crea un registro <strong>TXT</strong> para el hostname <strong><em>adsp.</em>domainkey</strong> y el valor del
TXT será <strong>dkim=all</strong>. A mi me quedó así:</p>

<pre><code class="cfg "registro"">_adsp._domainkey     IN      TXT     "dkim=all"
</code></pre>

<p>Con eso, tus correos no caerán más en la bandeja SPAM de gmail.</p>

<p>Otra cosa importante, asegúrate de tener el reverse lookup de tu MX bien puesto.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tls y ssl en postfix]]></title>
    <link href="http://uranio-235.github.io/blog/2015/11/03/tls-y-ssl-en-postfix/"/>
    <updated>2015-11-03T21:13:44-05:00</updated>
    <id>http://uranio-235.github.io/blog/2015/11/03/tls-y-ssl-en-postfix</id>
    <content type="html"><![CDATA[<p>Acá en salud, ahora <em>se están cayendo de la mata</em> y dándose cuenta de los
peligroso que son las conexiones planas.</p>

<p>Aún no logro hacerle entender a la gente, la diferencia entre un certificado
autofirmado y un certificado emitido por una <a href="https://es.wikipedia.org/wiki/Autoridad_de_certificaci%C3%B3n">autoridad de certificación</a>
; pero que más les vamos a pedir, si el certificado de nauta es autofirmado.</p>

<p>De momento con darle la muela del candadito y las letricas verdes en el
navegador, van cogiendo algo.</p>

<p>Pero volviendo al tema <strong>postfix con SSL</strong>. Vamos a crear un certificado
autofirmado, por tanto, regla de oro:</p>

<h4>el hostname que provees en el certificado, debe ser machear al del servicio</h4>

<p>En letra de molde. Si proveemos un certificado autofirmado, para conectarnos a
<strong>smtp.hcg.sld.cu</strong> no puedes decir en el cliente de correo, que el servidor
smtp es <strong>192.168.0.1</strong> porque no será válido.</p>

<p>Aún cuando el certificado no sea válido, déjame recodarte que debemos ir
haciéndole cultura de seguridad informática, si no&hellip; bueno&hellip; no me voy a meter
en un lío diciendo las barbaridades que se logran suplantando identidades.</p>

<p>Bueno entremos en materia. Lo Primero que haremos será generar la clave privada
para el servidor.</p>

<p>Donde dice <strong>smtp.tudominio.cu</strong> tu pondrás el hostname de que apunta para tu
servidor smtp. Si eres un desastre y no tiene DNS. Pon la IP de tu servidor de
correo.</p>

<h4>REPITO</h4>

<p>Donde dice <strong>FQDN or YOUR name</strong> debe decir la dirección del servidor SMTP. La
dirección tal cual la pones en los clientes.</p>

<p>Cuando lo hagas, te pedirá un password.</p>

<pre><code class="bash "generando clave privada del servidor"">openssl genrsa -des3 -out smtp.tudominio.cu.key 2048
</code></pre>

<p>Ahora creamos el certificado. Te pedirá hasta la talla de calzoncillos que usas.
<strong>NO respondas a lo locoi</strong>, recuerda el <strong>FQDN</strong>. Te acuerdas del password
que pusiste?</p>

<pre><code class="bash "creando el certificado"">openssl req -new -key smtp.tudominio.cu.key -out smtp.tudominio.cu.csr
</code></pre>

<p>Debes ver algo como esto:</p>

<pre><code class="bash "ceremonia de creación de certificado"">Enter pass phrase for smtp.tudominio.cu.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:CU
State or Province Name (full name) [Some-State]:Havana
Locality Name (eg, city) []:Plaza
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Calixto
Organizational Unit Name (eg, section) []:Informatica
Common Name (e.g. server FQDN or YOUR name) []:smtp.tudominio.cu
Email Address []:ssl@tudominio.cu
</code></pre>

<p>Bites verdad? Bueno, ya hicimos lo más importante, pero no hemos terminado.
Vamos a firmar el certificado con la la llave emisora.</p>

<pre><code class="bash "cri-cra firmando el certificado"">openssl x509 -req -days 365 -in smtp.tudominio.cu.csr -signkey smtp.tudominio.cu.key -out smtp.tudominio.cu.crt
</code></pre>

<p>Ahora vamos a dar un paso <strong>cuestionable</strong>.</p>

<p>Cada vez que un servicio con con un certificado SSL valla a ser iniciado.
Debería pedir un password, para así asegurar que el legítimo operador de
servicio ha sido quien le dio la arrancada. Pero poner un password cada vez que
arranca postfix, no es ninguna gracia. Por tanto, quitamos el password.
Obviamente, te lo pedirá una última vez.</p>

<pre><code class="bash "quitando el password"">openssl rsa -in smtp.tudominio.cu.key -out smtp.tudominio.cu.key.sinpassword
mv smtp.tudominio.cu.key.sinpassword smtp.tudominio.cu.key
</code></pre>

<p>Emitimos una autoridad de raíz (de pacotilla)</p>

<pre><code class="bash "la CA del chiste" ">openssl req -new -x509 -extensions v3_ca -keyout cakey.pem -out cacert.pem -days 3650
# aqui te pedirá la misma rutina, ojo con lo que pones en el campo FQDN or YOUR name
</code></pre>

<p>Bueno, con el disi y con el mulo, ya tenemos una CA loca, que la podemos reusar
para otros servicios, por tanto, tratemosla como tal.</p>

<pre><code class="bash "los puntos sobre las ies" ">chmod 600 smtp.tudominio.cu.key
chmod 600 cakey.pem
mv smtp.tudominio.cu.key /etc/ssl/private/
mv smtp.tudominio.cu.crt /etc/ssl/certs/
mv cakey.pem /etc/ssl/private/
mv cacert.pem /etc/ssl/certs/
</code></pre>

<p>Ahora viene el turno de postfix. Haremos dos cosas</p>

<ul>
<li>habilitar el tranporte ssl/tls por el puerto 465</li>
<li>habilitar las funciones ssl</li>
</ul>


<p>Ve al <strong>master.cf</strong> y busca la cadena de texto <strong>smtps</strong> debes ver algo como
esto:</p>

<pre><code class="bash "parte del master.cf ANTES"">smtp      inet  n       -       -       -       -       smtpd
#smtp      inet  n       -       -       -       1       postscreen
#smtpd     pass  -       -       -       -       -       smtpd
#dnsblog   unix  -       -       -       -       0       dnsblog
#tlsproxy  unix  -       -       -       -       0       tlsproxy
#submission inet n       -       -       -       -       smtpd
#  -o syslog_name=postfix/submission
#  -o smtpd_tls_security_level=encrypt
#  -o smtpd_sasl_auth_enable=yes
#  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
#  -o milter_macro_daemon_name=ORIGINATING
#smtps     inet  n       -       -       -       -       smtpd
#  -o syslog_name=postfix/smtps
#  -o smtpd_tls_wrappermode=yes
#  -o smtpd_sasl_auth_enable=yes
#  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
#  -o milter_macro_daemon_name=ORIGINATING
#628       inet  n       -       -       -       -       qmqpd
pickup    fifo  n       -       -       60      1       pickup
cleanup   unix  n       -       -       -       0       cleanup
</code></pre>

<p>Descomentamos todo lo que tenga que ver con <strong>smtps</strong> debe quedarte más o menos
así:</p>

<pre><code class="sh "parte del master.cf DESPUES"">smtp      inet  n       -       -       -       -       smtpd
#smtp      inet  n       -       -       -       1       postscreen
#smtpd     pass  -       -       -       -       -       smtpd
#dnsblog   unix  -       -       -       -       0       dnsblog
#tlsproxy  unix  -       -       -       -       0       tlsproxy
#submission inet n       -       -       -       -       smtpd
#  -o syslog_name=postfix/submission
#  -o smtpd_tls_security_level=encrypt
#  -o smtpd_sasl_auth_enable=yes
#  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
#  -o milter_macro_daemon_name=ORIGINATING
smtps     inet  n       -       -       -       -       smtpd
  -o syslog_name=postfix/smtps
  -o smtpd_tls_wrappermode=yes
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_client_restrictions=permit_sasl_authenticated,reject
  -o milter_macro_daemon_name=ORIGINATING
#628       inet  n       -       -       -       -       qmqpd
pickup    fifo  n       -       -       60      1       pickup
cleanup   unix  n       -       -       -       0       cleanup
</code></pre>

<p>Ahora trabajemos con el <strong>main.cf</strong>, habilitamos las funciones que tengan que
ver con SSL, declarando esto:</p>

<pre><code class="bash "tope del main.cf"">smtpd_use_tls = yes
smtpd_tls_auth_only = no
smtpd_tls_key_file = /etc/ssl/private/smtp.tudominio.cu.key
smtpd_tls_cert_file = /etc/ssl/certs/smtp.tudominio.cu.crt
smtpd_tls_CAfile = /etc/ssl/certs/cacert.pem
tls_random_source = dev:/dev/urandom
</code></pre>

<p>No olvides correr <strong>postfix reload</strong></p>

<p>   <blockquote><p>Te voy a coser el culo con un alambre finito.<br/>   No te quedará bonito, pero te quedará seguro.</p><footer><strong>Décima popular</strong></footer></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[repo de fdroid]]></title>
    <link href="http://uranio-235.github.io/blog/2015/10/15/repo-de-fdroid/"/>
    <updated>2015-10-15T14:38:20-04:00</updated>
    <id>http://uranio-235.github.io/blog/2015/10/15/repo-de-fdroid</id>
    <content type="html"><![CDATA[<p>&ldquo;La que se avecina&rdquo;, sería una buena manera para describir la revolución de
aparatos con android que habrá en el Calixto García muy pronto. Yo siempre con
el paso al frente y las luz larga (modestia y aparte) estuve pensando que tener
nuestro propio repositorio de aplicaciones para android; sería una buena manera
de mantener a todo el mundo bien actualizado, sobre todo a aquellos que no
tienen acceso a internet.</p>

<p>Para el que no lo conozca, <a href="https://f-droid.org/">fdroid</a> es una herramienta
cliente para repositorios de android, osea como google market pero libre.</p>

<p>La mecánica es sencilla: Bajo los paquetes con
<a href="http://www.aptoide.com">aptoide</a>, verifico que sean seguros y copio la cache
para el directorio repo/ de fdroid en el servidor con <a href="https://acrosync.com/">acrosync</a></p>

<p>En el repo de debian y en AUR, el paquete se llama <strong>fdroidserver</strong>. La rutina
de instalación ya la conoces.</p>

<p>Creamos el directorio donde meteremos el repo, en mi caso, aquí:</p>

<pre><code class="bash mkdir">mkdir -p /srv/http/fdroid/repo
</code></pre>

<p>Creamos la configuración de nginx, a mi me quedó así:</p>

<pre><code class="bash nginx.conf">server {
     listen   10.1.1.14:80;
     listen   10.1.1.14:443 ssl;
     server_name android.hcg.sld.cu;
     location / {
     root /srv/http/fdroid/repo/;
     }
}
</code></pre>

<p>Un virtualhost nombrado <em>android</em>. <strong>No olvide crear el puntero DNS</strong></p>

<p>Ahora, ve al directorio raíz del repo, OJO <strong>A LA RAIZ</strong>, NO a donde dice repo/.</p>

<pre><code class="bash fdroid">cd /srv/http/fdroid/
fdroid init
</code></pre>

<p>Te preguntará por la <strong>android-sdk</strong>, por lo general, está en /opt/android-sdk,
dale la ruta.</p>

<p>¿¿No tienes la SDK de android?? Ah pues estás muy jodio&hellip; En el caso de arch,
el repo de bbqlinux contiene la sdk completa, solo para 64 bits.</p>

<p>Pero volviendo con fdroid:</p>

<p>Ahora debe habérse creado el directorio <strong>repo/</strong> dentro del directorio
<strong>/srv/http/fdroid</strong> y es ahí donde copiarás las APK.</p>

<p>cp /donde/esten/tus/*.apk /srv/http/fdroid/<strong>repo/</strong></p>

<p>Pero claro, querrás que tu repo se identifique.  El fichero
<strong>/srv/http/fdroid/config.py</strong> contiene lo que buscas. Por la linea trenta y
pico; a mi me quedó así:</p>

<pre><code class="python config.py">...

repo_url = "http://android.hcg.sld.cu"
repo_name = "Calixto Garcia"
repo_icon = "calixto_xsm.png"
repo_description = """
Repositorio de aplicaciones de android del calixto. Intentaremos proveerle
aplicaciones debidamente actualizadas. Sientase libre de colaborar, trayendonos
las mas recientes APK.
"""

...
</code></pre>

<p>Ah! y sin tildes, si no, python se vuelve loco con el encoding.</p>

<p>Ahora vamos a crear el índice inicial, pero eso mismo comando lo correrás cuando
agregues aplicaciones a tu repo.</p>

<pre><code class="bash fdroid">fdroid update --create-metadata
</code></pre>

<p>OJO!! Asegúrate de que las APK no tengan un espacio en su nombre; muchísimo
menos un caracter raro. Si todo salió bien debes ver algo como &ldquo;Generating
metada&rdquo;.</p>

<p>Con eso terminaste el servidor&hellip; Ve a fdroid y ponle la URL del virtualhost
como repo, luego update y listo&hellip;</p>

<p>¿Cómo se hace? Facilito. Párate en la primer pantalla, aprieta el botón de menú
del dispositivo y toca donde dice &ldquo;Gestionar Repositorios&rdquo; o en inglés, &ldquo;Manage
Repos&rdquo;</p>

<p>Desactiva los respos inalcanzables y añade tu repo local. Luego actualiza y
listo, verás las aplicaciones disponibles.</p>

<p>Ya solo te quedaría instalar un rsync que desemboque en el repo y con
<a href="https://acrosync.com/">acrosync</a> subes la cache de aptotide para el repo, así
como lo estoy haciendo yo ahora.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[archlinux con dos kernel]]></title>
    <link href="http://uranio-235.github.io/blog/2015/09/07/archlinux-dos-kernel/"/>
    <updated>2015-09-07T20:32:57-04:00</updated>
    <id>http://uranio-235.github.io/blog/2015/09/07/archlinux-dos-kernel</id>
    <content type="html"><![CDATA[<p>Tener los dos kernel y elegir cual butear con el grub al principio; no es algo
sencillo en archlinux.</p>

<p>Por defecto, el grub dice tener dichas entradas en un submenú que nunca se ve.
Para lograrlo, tenemos que hacer unos paces mágicos en el fichero:</p>

<h4>/etc/default/grub</h4>

<p>Primero instalamos los kernels; el lts y el fresco.</p>

<pre><code class="bash "los kernels"">pacman -S linux linux-lts
</code></pre>

<p>Ahora la configuración con la que logré eso, fue agregándole al final estas
lineas:</p>

<pre><code class="bash "/etc/default/grub"">GRUB_DISABLE_SUBMENU=y
GRUB_DEFAULT=saved
GRUB_SAVEDEFAULT=true
</code></pre>

<p>Con eso, se salva la última entrada ejecutada. Por que, lo más obvio, es que la
próxima vez que arranques, se cargue el último kernel que usaste. Lo inusual
sería que cambies de opinión y cargues otro. Desgraciadamente, si como yo, usas
btrfs como sistema de archivo, grub no podrá escribir el fichero con la última
entrada seleccionada. Incluso te dará un error, diciendo que no puede escribir
el fichero no se que.</p>

<p>Seguimos&hellip; Localiza y la linea de recovery y ponla en false:</p>

<pre><code class="bash "/etc/default/grub""># Uncomment to disable generation of recovery mode menu entries
GRUB_DISABLE_RECOVERY=false
</code></pre>

<p><strong>NO SE POR QUE</strong>, pero no se generan las dichosas entradas si eso no está en
false. Además, tener el menú de recovery es bastante útil, en estas distros
volátiles, uno nunca sabe cuando le va a hacer falta.</p>

<p>Paso final, generar el grub.cfg</p>

<pre><code class="bash "grub-mkconfig"">grub-mkconfig -o /boot/grub/grub.cfg
</code></pre>

<p>Va y si quieres, no es obligado, pero para probar, <strong>REINICIA</strong>.</p>

<p>   <blockquote><p>Prefiero lidiar con las pifias de una comunidad<br/>   que con las mazmorras de una compañía.</p><footer><strong>Lázaro Armando</strong></footer></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[compute remote uptime]]></title>
    <link href="http://uranio-235.github.io/blog/2015/08/28/compute-remote-uptime/"/>
    <updated>2015-08-28T12:21:58-04:00</updated>
    <id>http://uranio-235.github.io/blog/2015/08/28/compute-remote-uptime</id>
    <content type="html"><![CDATA[<p>Vamos de atrás pa alante, el truco primero y la muela después.</p>

<pre><code class="bash "nmap"">[root@artema ~]# nmap -O -v 10.1.1.1|grep -i uptime
Uptime guess: 18.006 days (since Fri Aug 10 12:24:47 2015)
</code></pre>

<h4>¿Que acaba de suceder?</h4>

<p>Calculamos el tiempo que lleva el servidor remoto en pie. Fíjese que nos dice la
fecha en la que el servidor arrancó.</p>

<h4>¿Para que sirve esta información?</h4>

<p>Para poner al responsable de la computadora remota <em>contra las cuerdas</em> en una
situación crítica donde el momento de encendido o apagado de la máquina podría
ser crucial.</p>

<h4>Ejemplos:</h4>

<p>Nuestro proveedor, el servidor proxy padre, afirma descaradamente que NO ha
tenido problemas técnicos, pero nosotros sabemos que sí. En una discución
crucial podría dejarle caer la pregunta. <em>¿Entonces porque su servidor se
reinició el día tal?</em></p>

<p>Un servicio determinado falla a una hora determinada de la noche. Con esto
podríamos saber si el servidor se está reiniciando, cuando y con que frecuencia.</p>

<p>El proveedor dice que ha tenido que reiniciar el servidor cuando en realidad
nunca lo ha hecho.</p>

<p>El usuario dice que la máquina se le reinicia constantemente.</p>

<p>El usuario o el proveedor afirman que la máquina fue encendida a una hora
determinada. O por el contrario, se afirma que la máquina a esa hora NO estaba
encendida y el uptime dice lo contrario.</p>

<p>   <blockquote><p>Saque usted, sus propias concluciones&hellip;</p><footer><strong>Taladrid</strong> <cite>Pasaje a Lo Desconocido</cite></footer></blockquote></p>
]]></content>
  </entry>
  
</feed>
